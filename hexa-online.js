// Generated by Haxe 3.4.4
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); };
function $extend(from, fields) {
	function Inherit() {} Inherit.prototype = from; var proto = new Inherit();
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var CompilerError = function(except,details,line,column,filename) {
	this.exception = except;
	this.details = details == null ? "" : details;
	this.line = line == null ? 0 : line;
	this.column = column == null ? 0 : column;
	this.fileName = filename == null ? "" : filename;
};
CompilerError.__name__ = true;
CompilerError.prototype = {
	toString: function() {
		return "[" + this.fileName + ":" + this.line + ":" + this.column + "]: " + this.details;
	}
	,__class__: CompilerError
};
var Fail = { __ename__ : true, __constructs__ : ["ParserError","ParserInternalError","LexerError","TyperError","InfererError"] };
Fail.ParserError = ["ParserError",0];
Fail.ParserError.toString = $estr;
Fail.ParserError.__enum__ = Fail;
Fail.ParserInternalError = ["ParserInternalError",1];
Fail.ParserInternalError.toString = $estr;
Fail.ParserInternalError.__enum__ = Fail;
Fail.LexerError = ["LexerError",2];
Fail.LexerError.toString = $estr;
Fail.LexerError.__enum__ = Fail;
Fail.TyperError = ["TyperError",3];
Fail.TyperError.toString = $estr;
Fail.TyperError.__enum__ = Fail;
Fail.InfererError = ["InfererError",4];
Fail.InfererError.toString = $estr;
Fail.InfererError.__enum__ = Fail;
var Project = function() { };
Project.__name__ = true;
var NodeData = function(atLine,atColumn,atFile) {
	this.line = atLine;
	this.column = atColumn;
	this.fileName = atFile;
};
NodeData.__name__ = true;
NodeData.prototype = {
	__class__: NodeData
};
var Node = { __ename__ : true, __constructs__ : ["TString","TIdent","TBool","TThis","TSuper","TInt","TFloat","TNull","TBinop","TBlock","TCall","TIf","TParenthesis","TReturn","TThrow","TBreak","TContinue","TUnop","TWhile","TFunction","TVar","TVars","TClass","TTry","TDot","TNew","TArray","TMap","TIndex","TSwitch","TModule","TObject","TEnum","TEnumExtract","TDeclare","TUsing","TIs","TAs","TUnderscore","TStatic","TPrivate","TExport","TFor","TElvis","NodeTypeValue"] };
Node.TString = function(s) { var $x = ["TString",0,s]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TIdent = function(s) { var $x = ["TIdent",1,s]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TBool = function(b) { var $x = ["TBool",2,b]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TThis = ["TThis",3];
Node.TThis.toString = $estr;
Node.TThis.__enum__ = Node;
Node.TSuper = ["TSuper",4];
Node.TSuper.toString = $estr;
Node.TSuper.__enum__ = Node;
Node.TInt = function(s) { var $x = ["TInt",5,s]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TFloat = function(s) { var $x = ["TFloat",6,s]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TNull = ["TNull",7];
Node.TNull.toString = $estr;
Node.TNull.__enum__ = Node;
Node.TBinop = function(op,a,b) { var $x = ["TBinop",8,op,a,b]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TBlock = function(el) { var $x = ["TBlock",9,el]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TCall = function(e,args,argNames) { var $x = ["TCall",10,e,args,argNames]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TIf = function(econd,eif,eelse) { var $x = ["TIf",11,econd,eif,eelse]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TParenthesis = function(inner) { var $x = ["TParenthesis",12,inner]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TReturn = function(e) { var $x = ["TReturn",13,e]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TThrow = function(e) { var $x = ["TThrow",14,e]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TBreak = ["TBreak",15];
Node.TBreak.toString = $estr;
Node.TBreak.__enum__ = Node;
Node.TContinue = ["TContinue",16];
Node.TContinue.toString = $estr;
Node.TContinue.__enum__ = Node;
Node.TUnop = function(op,postfix,e) { var $x = ["TUnop",17,op,postfix,e]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TWhile = function(econd,e,pre) { var $x = ["TWhile",18,econd,e,pre]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TFunction = function(name,expr,vars,rettype) { var $x = ["TFunction",19,name,expr,vars,rettype]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TVar = function(name,t,expr,$const) { var $x = ["TVar",20,name,t,expr,$const]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TVars = function(vars) { var $x = ["TVars",21,vars]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TClass = function(t,ext,impl,fields,external) { var $x = ["TClass",22,t,ext,impl,fields,external]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TTry = function(expr,t,v,catches) { var $x = ["TTry",23,expr,t,v,catches]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TDot = function(expr,name) { var $x = ["TDot",24,expr,name]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TNew = function(t,args,fields,el) { var $x = ["TNew",25,t,args,fields,el]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TArray = function(elements) { var $x = ["TArray",26,elements]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TMap = function(keys,values) { var $x = ["TMap",27,keys,values]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TIndex = function(expr,index) { var $x = ["TIndex",28,expr,index]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TSwitch = function(exprs,conds,cases) { var $x = ["TSwitch",29,exprs,conds,cases]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TModule = function(path,el) { var $x = ["TModule",30,path,el]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TObject = function(names,el) { var $x = ["TObject",31,names,el]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TEnum = function(t,fields) { var $x = ["TEnum",32,t,fields]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TEnumExtract = function(expr,extract,name) { var $x = ["TEnumExtract",33,expr,extract,name]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TDeclare = function(name,t) { var $x = ["TDeclare",34,name,t]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TUsing = function(path) { var $x = ["TUsing",35,path]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TIs = function(expr,t) { var $x = ["TIs",36,expr,t]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TAs = function(expr,kind,t) { var $x = ["TAs",37,expr,kind,t]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TUnderscore = ["TUnderscore",38];
Node.TUnderscore.toString = $estr;
Node.TUnderscore.__enum__ = Node;
Node.TStatic = function(field) { var $x = ["TStatic",39,field]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TPrivate = function(field) { var $x = ["TPrivate",40,field]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TExport = function(field) { var $x = ["TExport",41,field]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TFor = function(name,over,by) { var $x = ["TFor",42,name,over,by]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.TElvis = function(nullable,othewise) { var $x = ["TElvis",43,nullable,othewise]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
Node.NodeTypeValue = function(type) { var $x = ["NodeTypeValue",44,type]; $x.__enum__ = Node; $x.toString = $estr; return $x; };
var DataHelper = function() { };
DataHelper.__name__ = true;
DataHelper.varName = function(v) {
	if(v[1] == 20) {
		var name = v[2];
		return name;
	} else {
		throw new js__$Boot_HaxeError("varName got not a TVar, but `" + Std.string(v) + "`");
	}
};
var NodeType = { __ename__ : true, __constructs__ : ["Type","ParamentricType","Function","FunctionArg","Object"] };
NodeType.Type = function(name) { var $x = ["Type",0,name]; $x.__enum__ = NodeType; $x.toString = $estr; return $x; };
NodeType.ParamentricType = function(name,params) { var $x = ["ParamentricType",1,name,params]; $x.__enum__ = NodeType; $x.toString = $estr; return $x; };
NodeType.Function = function(args,ret) { var $x = ["Function",2,args,ret]; $x.__enum__ = NodeType; $x.toString = $estr; return $x; };
NodeType.FunctionArg = function(name,type,defaultValue) { var $x = ["FunctionArg",3,name,type,defaultValue]; $x.__enum__ = NodeType; $x.toString = $estr; return $x; };
NodeType.Object = function(names,types) { var $x = ["Object",4,names,types]; $x.__enum__ = NodeType; $x.toString = $estr; return $x; };
var GeneratorHelper = function() { };
GeneratorHelper.__name__ = true;
var GenJs = function() { };
GenJs.__name__ = true;
GenJs.rename = function(name) {
	if(GenJs.reserved.indexOf(name) != -1) {
		return "$" + name;
	}
	return name;
};
GenJs.stringifyBlockExpression = function(node) {
	var r = "";
	switch(node[1]) {
	case 11:
		if(node[2].length == 1) {
			if(node[2][0][1] == 20) {
				var eelse = node[4];
				var eif = node[3];
				var $const = node[2][0][5];
				var expr = node[2][0][4];
				var t = node[2][0][3];
				var oname = node[2][0][2];
				var cond = node[2][0];
				r += "\n" + GenJs.tabs + "{\n";
				GenJs.tabs += "\t";
				GenJs.pushScope();
				GenJs.parentNames.set(cond,oname);
				r += GenJs.tabs + "const " + oname + " = " + GenJs.stringify(expr) + "\n" + GenJs.tabs;
				r += "if(" + oname + " != null) ";
				r += eif[1] == 9 ? GenJs.stringify(eif) : GenJs.stringify(Node.TBlock([eif]));
				if(eelse != null) {
					r += " else " + GenJs.stringifyBlockExpression(eelse);
				}
				GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
				GenJs.popScope();
				return r + "\n" + GenJs.tabs + "}";
			} else {
				var eelse1 = node[4];
				var eif1 = node[3];
				var econd = node[2][0];
				r += "if (" + GenJs.stringify(econd) + ") ";
				r += eif1[1] == 9 ? GenJs.stringify(eif1) : GenJs.stringify(Node.TBlock([eif1]));
				if(eelse1 != null) {
					r += " else " + GenJs.stringifyBlockExpression(eelse1);
				}
				return r;
			}
		} else {
			var eelse2 = node[4];
			var eif2 = node[3];
			var econd1 = node[2];
			GenJs.tabs += "\t";
			r += "{\n" + GenJs.tabs;
			if(eelse2 != null) {
				GenJs.addToScope("else$$");
				r += "const else$$ = () => " + GenJs.stringify(eelse2) + "\n" + GenJs.tabs;
			}
			var depth = 0;
			var econds = econd1;
			var i = 0;
			var condsstr = "";
			var constsstr = "";
			var addCond = function(cond1) {
				if(condsstr == "") {
					return cond1;
				} else {
					return " && " + cond1;
				}
			};
			while(econds[i] != null) {
				var cond2 = econds[i];
				condsstr = "";
				constsstr = "";
				while(true) {
					var innercond = econds[i];
					if(innercond[1] == 20) {
						var const1 = innercond[5];
						var expr1 = innercond[4];
						var t1 = innercond[3];
						var oname1 = innercond[2];
						GenJs.addToScope(oname1);
						var name = GenJs.rename(oname1);
						GenJs.parentNames.set(cond2,name);
						constsstr += "const " + name + " = " + GenJs.stringify(expr1) + ";\n" + GenJs.tabs;
						condsstr += addCond(name + " != null");
					} else {
						condsstr += addCond(GenJs.stringify(innercond));
					}
					if(econds[i + 1] != null) {
						var _g = econds[i + 1];
						if(_g[1] == 20) {
							var const2 = _g[5];
							var expr2 = _g[4];
							var t2 = _g[3];
							var oname2 = _g[2];
							break;
						}
					}
					++i;
					if(!(econds[i] != null)) {
						break;
					}
				}
				r += constsstr;
				r += "if(" + condsstr + ") {";
				GenJs.tabs += "\t";
				r += "\n" + GenJs.tabs;
				++depth;
				++i;
			}
			r += eif2[1] == 9 ? GenJs.stringify(eif2) : GenJs.stringify(Node.TBlock([eif2]));
			while(depth > 0) {
				GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
				r += "\n" + GenJs.tabs + "}";
				if(eelse2 != null) {
					r += " else else$$()";
				}
				--depth;
			}
			GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
			r += "\n" + GenJs.tabs + "}";
			return r;
		}
		break;
	case 19:
		var vars = node[4];
		var expr3 = node[3];
		var name1 = node[2];
		GenJs.pushScope();
		var newname = GenJs.rename(name1);
		var _g1 = [];
		var _g11 = 0;
		while(_g11 < vars.length) {
			var v = vars[_g11];
			++_g11;
			var vars1;
			switch(v[1]) {
			case 1:
				var oname3 = v[2];
				var name2 = GenJs.rename(oname3);
				if(GenJs.hasInScope(name2)) {
					name2 += "$" + ++GenJs.id;
				}
				GenJs.addToScope(name2);
				GenJs.parentNames.set(v,name2);
				vars1 = GenJs.parentNames.get(v);
				break;
			case 12:
				if(v[2] == null) {
					vars1 = "";
				} else {
					throw new js__$Boot_HaxeError(v);
				}
				break;
			case 20:
				var oname4 = v[2];
				var name3 = GenJs.rename(oname4);
				if(GenJs.hasInScope(name3)) {
					name3 += "$" + ++GenJs.id;
				}
				GenJs.addToScope(name3);
				GenJs.parentNames.set(v,name3);
				vars1 = GenJs.parentNames.get(v);
				break;
			default:
				throw new js__$Boot_HaxeError(v);
			}
			_g1.push(vars1);
		}
		var vars2 = _g1.join(", ");
		var funcbody = "";
		if(expr3 != null) {
			if(expr3[1] == 9) {
				var el = expr3[2];
				funcbody = GenJs.stringify(expr3);
			} else {
				GenJs.pushScope();
				GenJs.tabs += "\t";
				funcbody = "{\n" + GenJs.tabs + GenJs.stringify(expr3) + ("\n\t" + GenJs.tabs + "}");
				GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
				GenJs.popScope();
			}
		} else {
			funcbody = "{}";
		}
		GenJs.popScope();
		return "const " + newname + " = (" + vars2 + ") => " + funcbody;
	default:
		return GenJs.stringify(node);
	}
};
GenJs.getAtt = function(atts,atname) {
	if(atts != null && atts.length > 0) {
		var _g = 0;
		while(_g < atts.length) {
			var att = atts[_g];
			++_g;
			if(att.name == atname) {
				return att;
			}
		}
	}
	return null;
};
GenJs.pushScope = function() {
	GenJs.scopes.push(new Map());
};
GenJs.popScope = function() {
	GenJs.scopes.pop();
};
GenJs.hasInScope = function(name) {
	var _g = 0;
	var _g1 = GenJs.scopes;
	while(_g < _g1.length) {
		var scope = _g1[_g];
		++_g;
		if(scope.get(name) != null) {
			return true;
		}
	}
	return false;
};
GenJs.addToScope = function(name) {
	GenJs.scopes[GenJs.scopes.length - 1].set(name,true);
};
GenJs.stringify = function(node) {
	var r = "";
	if(node == null) {
		throw new js__$Boot_HaxeError("Unable to print: node is null");
	}
	var atts = Project.mapAttributes.get(node);
	var a = "";
	if(atts != null && atts.length > 0) {
		var _g = 0;
		while(_g < atts.length) {
			var att = atts[_g];
			++_g;
			a += "/* @" + att.name + "*/ ";
		}
	}
	var tmp;
	switch(node[1]) {
	case 0:
		var s = node[2];
		var s1 = s.split("");
		var charsOut = [];
		while(s1.length > 0) {
			var _g1 = s1[0];
			switch(_g1) {
			case "\n":
				charsOut.push("\\n");
				s1.shift();
				break;
			case "\r":
				charsOut.push("\\r");
				s1.shift();
				break;
			case "'":
				charsOut.push("\\'");
				s1.shift();
				break;
			case "\\":
				s1.shift();
				if(s1[0] == "'") {
					charsOut.push("\\'");
					s1.shift();
				} else {
					charsOut.push("\\");
				}
				break;
			default:
				charsOut.push(s1[0]);
				s1.shift();
			}
		}
		tmp = "'" + charsOut.join("") + "'";
		break;
	case 1:
		var s2 = node[2];
		var source = Project.mapNames.get(node);
		var n;
		if(source == null) {
			throw new js__$Boot_HaxeError("Unmapped " + Std.string(node));
		} else {
			switch(source[1]) {
			case 1:
				var name = source[2];
				n = GenJs.parentNames.get(source);
				break;
			case 19:
				var name1 = source[2];
				n = GenJs.rename(name1);
				break;
			case 20:
				var name2 = source[2];
				var n1 = GenJs.parentNames.get(source);
				if(n1 == null) {
					throw new js__$Boot_HaxeError("TVar `" + name2 + "` parentNames null == " + GenJs.parentNames.get(source) + " for " + Std.string(source));
				}
				n = n1;
				break;
			case 22:
				var t = source[2];
				var rename = GenJs.getAtt(Project.mapAttributes.get(source),"native");
				var name3 = GenJs.rename(GenJs.extractTypeName(t));
				if(rename != null) {
					var _g2 = rename.values[0];
					if(_g2 == null) {
						n = name3;
					} else if(_g2[1] == 0) {
						var s3 = _g2[2];
						n = s3;
					} else {
						n = name3;
					}
				} else {
					n = name3;
				}
				break;
			case 32:
				if(source[2][1] == 0) {
					var name4 = source[2][2];
					n = name4;
				} else {
					throw new js__$Boot_HaxeError("" + s2 + " " + Std.string(source));
				}
				break;
			case 34:
				var t1 = source[3];
				var name5 = source[2];
				var n2 = GenJs.parentNames.get(source);
				if(n2 == null) {
					throw new js__$Boot_HaxeError("TDeclare `" + name5 + "` parentNames null == " + GenJs.parentNames.get(source) + " for " + Std.string(source));
				}
				n = n2;
				break;
			case 39:
				if(source[2][1] == 20) {
					var name6 = source[2][2];
					var f = source[2];
					var static_source = Project.mapNames.get(source);
					switch(static_source[1]) {
					case 22:
						var t2 = static_source[2];
						n = GenJs.rename(GenJs.extractTypeName(t2)) + "." + GenJs.rename(name6);
						break;
					case 32:
						var t3 = static_source[2];
						n = GenJs.rename(GenJs.extractTypeName(t3)) + "." + GenJs.rename(name6);
						break;
					default:
						throw new js__$Boot_HaxeError("static_source is " + Std.string(static_source));
					}
				} else {
					throw new js__$Boot_HaxeError("" + s2 + " " + Std.string(source));
				}
				break;
			case 42:
				var name7 = source[2];
				n = GenJs.parentNames.get(source);
				break;
			default:
				throw new js__$Boot_HaxeError("" + s2 + " " + Std.string(source));
			}
		}
		tmp = n;
		break;
	case 2:
		if(node[2] == true) {
			tmp = "true";
		} else {
			tmp = "false";
		}
		break;
	case 3:
		tmp = "this";
		break;
	case 4:
		tmp = "super";
		break;
	case 5:
		var s4 = node[2];
		tmp = s4;
		break;
	case 6:
		var s5 = node[2];
		tmp = s5;
		break;
	case 7:
		tmp = "null";
		break;
	case 8:
		var b = node[4];
		var a1 = node[3];
		var op = node[2];
		tmp = GenJs.stringify(a1) + " " + _$Token_Token_$Impl_$.stringify(op) + " " + GenJs.stringify(b);
		break;
	case 9:
		if(node[2].length == 0) {
			tmp = "{}";
		} else {
			var elements = node[2];
			r = "{\n";
			GenJs.pushScope();
			GenJs.tabs += "\t";
			var _g3 = 0;
			while(_g3 < elements.length) {
				var element = elements[_g3];
				++_g3;
				var code = GenJs.tabs + GenJs.stringifyBlockExpression(element) + "\n";
				r += code;
			}
			GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
			GenJs.popScope();
			tmp = r + GenJs.tabs + "}";
		}
		break;
	case 10:
		var argNames = node[4];
		var el = node[3];
		var e = node[2];
		var source1 = Project.mapNames.get(e);
		if(source1 == null) {
			var tmp1 = GenJs.stringify(e) + "(";
			var _g4 = [];
			var _g11 = 0;
			while(_g11 < el.length) {
				var e1 = el[_g11];
				++_g11;
				_g4.push(GenJs.stringify(e1));
			}
			tmp = tmp1 + _g4.join(", ") + ")";
		} else if(source1[1] == 19) {
			if(source1[2] == "instanceof") {
				tmp = "((" + GenJs.stringify(el[0]) + ") instanceof (" + GenJs.stringify(el[1]) + "))";
			} else {
				var tmp2 = GenJs.stringify(e) + "(";
				var _g5 = [];
				var _g12 = 0;
				while(_g12 < el.length) {
					var e2 = el[_g12];
					++_g12;
					_g5.push(GenJs.stringify(e2));
				}
				tmp = tmp2 + _g5.join(", ") + ")";
			}
		} else {
			var tmp3 = GenJs.stringify(e) + "(";
			var _g6 = [];
			var _g13 = 0;
			while(_g13 < el.length) {
				var e3 = el[_g13];
				++_g13;
				_g6.push(GenJs.stringify(e3));
			}
			tmp = tmp3 + _g6.join(", ") + ")";
		}
		break;
	case 11:
		var eelse = node[4];
		var eif = node[3];
		var econd = node[2];
		var _g7 = [];
		var _g14 = 0;
		while(_g14 < econd.length) {
			var e4 = econd[_g14];
			++_g14;
			_g7.push(GenJs.stringify(e4));
		}
		r = "(" + _g7.join(" && ") + ")? (" + GenJs.stringify(eif);
		if(eelse != null) {
			r += ") : (" + GenJs.stringify(eelse) + ")";
		}
		tmp = r;
		break;
	case 12:
		var e5 = node[2];
		tmp = "(" + GenJs.stringify(e5) + ")";
		break;
	case 13:
		if(node[2] == null) {
			tmp = "return ";
		} else if(node[2][1] == 9) {
			if(node[2][2].length == 0) {
				tmp = "return ";
			} else {
				var e6 = node[2];
				tmp = "return " + GenJs.stringify(e6);
			}
		} else {
			var e7 = node[2];
			tmp = "return " + GenJs.stringify(e7);
		}
		break;
	case 14:
		var e8 = node[2];
		tmp = "throw " + GenJs.stringify(e8) + "";
		break;
	case 15:
		tmp = "break";
		break;
	case 16:
		tmp = "continue";
		break;
	case 17:
		var e9 = node[4];
		var postfix = node[3];
		var op1 = node[2];
		if(postfix) {
			tmp = GenJs.stringify(e9) + _$Token_Token_$Impl_$.stringify(op1);
		} else {
			tmp = _$Token_Token_$Impl_$.stringify(op1) + GenJs.stringify(e9);
		}
		break;
	case 18:
		switch(node[4]) {
		case false:
			var econd1 = node[2];
			var e10 = node[3];
			tmp = "do{" + GenJs.stringify(e10) + "}while(" + GenJs.stringify(econd1) + ")";
			break;
		case true:
			var econd2 = node[2];
			var e11 = node[3];
			tmp = "while(" + GenJs.stringify(econd2) + ") " + GenJs.stringify(e11);
			break;
		}
		break;
	case 19:
		var vars = node[4];
		var expr = node[3];
		var name8 = node[2];
		GenJs.pushScope();
		r = "function";
		if(name8 != null) {
			r += " " + GenJs.rename(name8);
		}
		var _g15 = [];
		var _g21 = 0;
		while(_g21 < vars.length) {
			var v = vars[_g21];
			++_g21;
			var r1;
			switch(v[1]) {
			case 1:
				var oname = v[2];
				var name9 = GenJs.rename(oname);
				if(GenJs.hasInScope(name9)) {
					name9 += "$" + ++GenJs.id;
				}
				GenJs.addToScope(name9);
				GenJs.parentNames.set(v,name9);
				r1 = GenJs.parentNames.get(v);
				break;
			case 12:
				if(v[2] == null) {
					r1 = "";
				} else {
					throw new js__$Boot_HaxeError(v);
				}
				break;
			case 20:
				var oname1 = v[2];
				var name10 = GenJs.rename(oname1);
				if(GenJs.hasInScope(name10)) {
					name10 += "$" + ++GenJs.id;
				}
				GenJs.addToScope(name10);
				GenJs.parentNames.set(v,name10);
				r1 = GenJs.parentNames.get(v);
				break;
			default:
				throw new js__$Boot_HaxeError(v);
			}
			_g15.push(r1);
		}
		r += "(" + _g15.join(", ") + ") ";
		if(expr != null) {
			if(expr[1] == 9) {
				var el1 = expr[2];
				r += GenJs.stringify(expr);
			} else {
				GenJs.pushScope();
				GenJs.tabs += "\t";
				r += "{\n" + GenJs.tabs + GenJs.stringify(expr) + ("\n\t" + GenJs.tabs + "}");
				GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
				GenJs.popScope();
			}
		} else {
			r += "{}";
		}
		GenJs.popScope();
		tmp = r;
		break;
	case 20:
		var $const = node[5];
		var expr1 = node[4];
		var t4 = node[3];
		var oname2 = node[2];
		if(oname2 == null) {
			throw new js__$Boot_HaxeError("name is null for " + Std.string(node));
		}
		var es = "";
		if(expr1 != null) {
			es = " = " + GenJs.stringify(expr1);
		}
		var name11 = GenJs.rename(oname2);
		if(GenJs.hasInScope(name11)) {
			name11 += "$" + ++GenJs.id;
		}
		GenJs.addToScope(name11);
		GenJs.parentNames.set(node,name11);
		if(name11 == null) {
			throw new js__$Boot_HaxeError("name is null for " + Std.string(node));
		}
		r = ($const ? "const " : "let ") + name11 + es;
		tmp = r;
		break;
	case 21:
		var e12 = node[2];
		var _g8 = [];
		var _g16 = 0;
		while(_g16 < e12.length) {
			var e13 = e12[_g16];
			++_g16;
			_g8.push(GenJs.stringify(e13));
		}
		tmp = _g8.join("; ");
		break;
	case 22:
		if(node[6] == true) {
			var t5 = node[2];
			var ext = node[3];
			var impl = node[4];
			var fields = node[5];
			var cname = GenJs.extractTypeName(t5);
			var $require = GenJs.getAtt(Project.mapAttributes.get(node),"require");
			if($require != null) {
				var _g9 = $require.values[1];
				var _g17 = $require.values[0];
				if(_g17[1] == 0) {
					if(_g9 == null) {
						var s6 = _g17[2];
						r += "const " + cname + " = require(\"" + s6 + "\");\n" + GenJs.tabs;
					} else if(_g9[1] == 0) {
						var s7 = _g17[2];
						var f1 = _g9[2];
						r += "const " + cname + " = require(\"" + s7 + "\")." + f1 + ";\n" + GenJs.tabs;
					} else {
						throw new js__$Boot_HaxeError("@require takes string as argument");
					}
				} else {
					throw new js__$Boot_HaxeError("@require takes string as argument");
				}
			}
			r += "/* declare class " + cname + " */";
			tmp = r;
		} else {
			var t6 = node[2];
			var ext1 = node[3];
			var impl1 = node[4];
			var fields1 = node[5];
			var external = node[6];
			var cname1 = GenJs.extractTypeName(t6);
			r = (external ? "/* declare class " : "class ") + cname1;
			if(ext1 != null) {
				r += " extends " + GenJs.extractTypeName(ext1);
			}
			r += " {\n";
			var after = [];
			var _g10 = 0;
			while(_g10 < fields1.length) {
				var f2 = fields1[_g10];
				++_g10;
				var code1 = "";
				var isafter = false;
				var unmeta = function(f3) {
					return f3;
				};
				f2 = unmeta(f2);
				if(f2[1] == 39) {
					var field = f2[2];
					f2 = field;
					isafter = true;
				}
				f2 = unmeta(f2);
				switch(f2[1]) {
				case 19:
					var vars1 = f2[4];
					var expr2 = f2[3];
					var name12 = f2[2];
					if(name12 == "new") {
						name12 = "constructor";
					}
					if(isafter) {
						code1 += cname1 + "." + GenJs.rename(name12) + " = function";
					} else {
						code1 += "\t" + GenJs.rename(name12);
					}
					var _g22 = [];
					var _g31 = 0;
					while(_g31 < vars1.length) {
						var v1 = vars1[_g31];
						++_g31;
						var code2;
						if(v1[1] == 20) {
							var oname3 = v1[2];
							var name13 = GenJs.rename(oname3);
							if(GenJs.hasInScope(name13)) {
								name13 += "$" + ++GenJs.id;
							}
							GenJs.addToScope(name13);
							GenJs.parentNames.set(v1,name13);
							code2 = GenJs.parentNames.get(v1);
						} else {
							throw new js__$Boot_HaxeError(v1);
						}
						_g22.push(code2);
					}
					code1 += "(" + _g22.join(", ") + ") ";
					if(expr2 != null) {
						if(expr2[1] == 9) {
							var el2 = expr2[2];
							GenJs.tabs += "\t";
							code1 += GenJs.stringify(expr2);
							GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
						} else {
							GenJs.tabs += "\t";
							code1 += "{\n" + GenJs.tabs + GenJs.stringify(expr2);
							GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
							code1 += "\n" + GenJs.tabs + "}";
						}
					} else {
						code1 += "{}";
					}
					break;
				case 20:
					var const1 = f2[5];
					var expr3 = f2[4];
					var t7 = f2[3];
					var name14 = f2[2];
					isafter = true;
					code1 += cname1 + "." + GenJs.rename(name14);
					if(expr3 != null) {
						code1 += " = " + GenJs.stringify(expr3);
					}
					break;
				default:
					code1 += "" + Std.string(f2);
				}
				if(isafter) {
					after.push(GenJs.tabs + code1);
				} else {
					r += "\t" + code1;
				}
			}
			r += "\n" + GenJs.tabs + "}" + (external ? " */" : "");
			r += "\n" + after.join(";\n");
			tmp = r;
		}
		break;
	case 23:
		var catches = node[5];
		var v2 = node[4];
		var t8 = node[3];
		var expr4 = node[2];
		r = "try {\n" + GenJs.tabs + "\t";
		GenJs.tabs += "\t";
		if(expr4[1] == 9) {
			var el3 = expr4[2];
			var _g18 = [];
			var _g23 = 0;
			while(_g23 < el3.length) {
				var e14 = el3[_g23];
				++_g23;
				_g18.push(GenJs.stringifyBlockExpression(e14));
			}
			r += _g18.join(";\n" + GenJs.tabs);
		} else {
			r += GenJs.stringify(expr4);
		}
		GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
		r += "\n" + GenJs.tabs + "} catch(" + DataHelper.varName(v2[0]) + (") {\n" + GenJs.tabs + "\t");
		GenJs.tabs += "\t";
		GenJs.parentNames.set(v2[0],DataHelper.varName(v2[0]));
		var _g19 = catches[0];
		if(_g19[1] == 9) {
			var el4 = _g19[2];
			var _g110 = [];
			var _g24 = 0;
			while(_g24 < el4.length) {
				var e15 = el4[_g24];
				++_g24;
				_g110.push(GenJs.stringify(e15));
			}
			r += _g110.join(";\n" + GenJs.tabs);
		} else {
			r += GenJs.stringify(catches[0]);
		}
		GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
		tmp = r + "\n" + GenJs.tabs + "}";
		break;
	case 24:
		if(node[2][1] == 0) {
			if(node[3] == "length") {
				var s8 = node[2][2];
				tmp = "" + s8.length;
			} else {
				var expr5 = node[2];
				var name15 = node[3];
				tmp = GenJs.stringify(expr5) + "." + GenJs.rename(name15);
			}
		} else {
			var name16 = node[3];
			var expr6 = node[2];
			tmp = GenJs.stringify(expr6) + "." + GenJs.rename(name16);
		}
		break;
	case 25:
		var values = node[5];
		var names = node[4];
		var args = node[3];
		var t9 = node[2];
		var tmp4 = "new " + GenJs.extractTypeName(t9) + "(";
		var _g20 = [];
		var _g111 = 0;
		while(_g111 < args.length) {
			var e16 = args[_g111];
			++_g111;
			_g20.push(GenJs.stringify(e16));
		}
		tmp = tmp4 + _g20.join(",") + ")";
		break;
	case 26:
		if(node[2].length == 1) {
			if(node[2][0][1] == 42) {
				var expr7 = node[2][0][4];
				var array = node[2][0][3];
				var oname4 = node[2][0][2];
				var f4 = node[2][0];
				GenJs.pushScope();
				r += "((()=>{";
				r += "const return$$ = []; ";
				var name17 = GenJs.rename(oname4);
				if(GenJs.hasInScope(name17)) {
					name17 += "$" + ++GenJs.id;
				}
				GenJs.addToScope(name17);
				GenJs.parentNames.set(f4,name17);
				r += "for (const " + name17 + " of " + GenJs.stringify(array) + ") ";
				r += "return$$.push(";
				r += GenJs.stringify(expr7);
				r += "); return return$$;";
				r += "})())";
				GenJs.popScope();
				tmp = r;
			} else {
				var el5 = node[2];
				var _g25 = [];
				var _g112 = 0;
				while(_g112 < el5.length) {
					var e17 = el5[_g112];
					++_g112;
					_g25.push(GenJs.stringify(e17));
				}
				tmp = "[" + _g25.join(", ") + "]";
			}
		} else {
			var el6 = node[2];
			var _g26 = [];
			var _g113 = 0;
			while(_g113 < el6.length) {
				var e18 = el6[_g113];
				++_g113;
				_g26.push(GenJs.stringify(e18));
			}
			tmp = "[" + _g26.join(", ") + "]";
		}
		break;
	case 27:
		if(node[2].length == 0) {
			tmp = "new Map()";
		} else {
			var values1 = node[3];
			var keys = node[2];
			var _g27 = [];
			var _g28 = 0;
			var _g114 = keys.length;
			while(_g28 < _g114) {
				var i = _g28++;
				_g27.push("[" + GenJs.stringify(keys[i]) + "," + GenJs.stringify(values1[i]) + "]");
			}
			tmp = "new Map([" + _g27.join(",") + "])";
		}
		break;
	case 28:
		var index = node[3];
		var expr8 = node[2];
		tmp = GenJs.stringify(expr8) + "[" + GenJs.stringify(index) + "]";
		break;
	case 29:
		var cases = node[4];
		var conds = node[3];
		var exprs = node[2];
		r = "switch (";
		r += GenJs.stringify(exprs[0]);
		r += ") {\n";
		GenJs.tabs += "\t";
		var _g115 = 0;
		var _g29 = cases.length;
		while(_g115 < _g29) {
			var i1 = _g115++;
			var c = cases[i1];
			r += GenJs.tabs;
			var _g210 = 0;
			var _g32 = conds[i1];
			while(_g210 < _g32.length) {
				var c1 = _g32[_g210];
				++_g210;
				r += "case " + GenJs.stringify(c1) + ":";
			}
			r += " {\n";
			r += GenJs.tabs + "\t" + GenJs.stringify(c) + ";\n";
			r += GenJs.tabs + "\t" + "break;" + "\n" + ("" + GenJs.tabs + "}") + "\n";
		}
		GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
		tmp = r + GenJs.tabs + "}";
		break;
	case 30:
		var el7 = node[3];
		var path = node[2];
		r = "module " + path.join(".") + " {\n";
		GenJs.tabs += "\t";
		var _g30 = 0;
		while(_g30 < el7.length) {
			var e19 = el7[_g30];
			++_g30;
			r += GenJs.tabs + GenJs.stringify(e19) + ";\n";
		}
		GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
		tmp = r + GenJs.tabs + "}";
		break;
	case 31:
		if(node[2].length == 0) {
			tmp = "{}";
		} else {
			var el8 = node[3];
			var names1 = node[2];
			var _g33 = [];
			var _g211 = 0;
			var _g116 = el8.length;
			while(_g211 < _g116) {
				var i2 = _g211++;
				_g33.push(GenJs.rename(names1[i2]) + ":" + GenJs.stringify(el8[i2]));
			}
			tmp = "{" + _g33.join(",") + "}";
		}
		break;
	case 32:
		var fields2 = node[3];
		var t10 = node[2];
		r = "const " + GenJs.extractTypeName(t10);
		r += " = {\n";
		GenJs.tabs += "\t";
		var _g34 = 0;
		while(_g34 < fields2.length) {
			var f5 = fields2[_g34];
			++_g34;
			switch(f5[1]) {
			case 1:
				var name18 = f5[2];
				r += GenJs.tabs + name18 + ":{},\n";
				break;
			case 8:
				if(f5[2] == 91) {
					if(f5[3][1] == 1) {
						var val = f5[4];
						var name19 = f5[3][2];
						r += GenJs.tabs + name19 + ":" + GenJs.stringify(val) + ",\n";
					} else {
						throw new js__$Boot_HaxeError("!" + Std.string(f5));
					}
				} else {
					throw new js__$Boot_HaxeError("!" + Std.string(f5));
				}
				break;
			default:
				throw new js__$Boot_HaxeError("!" + Std.string(f5));
			}
		}
		GenJs.tabs = GenJs.tabs.substring(0,GenJs.tabs.length - 1);
		tmp = r + GenJs.tabs + "}";
		break;
	case 33:
		var name20 = node[4];
		var extract = node[3];
		var tenum = node[2];
		tmp = "/*tenumxtract*/";
		break;
	case 34:
		if(node[3][1] == 22) {
			var fields3 = node[3][5];
			var impl2 = node[3][4];
			var ext2 = node[3][3];
			var t11 = node[3][2];
			var vnode = node[3];
			var cname2 = GenJs.extractTypeName(t11);
			var require1 = GenJs.getAtt(Project.mapAttributes.get(vnode),"require");
			if(require1 != null) {
				var _g35 = require1.values[1];
				var _g117 = require1.values[0];
				if(_g117[1] == 0) {
					if(_g35 == null) {
						var s9 = _g117[2];
						r += "const " + cname2 + " = require(\"" + s9 + "\");\n" + GenJs.tabs;
					} else if(_g35[1] == 0) {
						var s10 = _g117[2];
						var f6 = _g35[2];
						r += "const " + cname2 + " = require(\"" + s10 + "\")." + f6 + ";\n" + GenJs.tabs;
					} else {
						throw new js__$Boot_HaxeError("@require takes string as argument");
					}
				} else {
					throw new js__$Boot_HaxeError("@require takes string as argument");
				}
			}
			r += "/* declare class " + cname2 + " */";
			tmp = r;
		} else {
			var name21 = node[2];
			var vnode1 = node[3];
			GenJs.parentNames.set(node,name21);
			tmp = "//declare " + name21;
		}
		break;
	case 35:
		var names2 = node[2];
		tmp = "/*using " + Std.string(names2) + "*/";
		break;
	case 36:
		var t12 = node[3];
		var expr9 = node[2];
		tmp = "";
		break;
	case 37:
		var t13 = node[4];
		var kind = node[3];
		var expr10 = node[2];
		tmp = "(" + GenJs.stringify(expr10) + ")";
		break;
	case 38:
		tmp = "_";
		break;
	case 39:
		var field1 = node[2];
		tmp = "static " + GenJs.stringify(field1);
		break;
	case 40:
		var f7 = node[2];
		tmp = "/*tprivate*/";
		break;
	case 41:
		var f8 = node[2];
		tmp = "/*texport*/";
		break;
	case 42:
		var b1 = node[4];
		var a2 = node[3];
		var n3 = node[2];
		GenJs.pushScope();
		var name22 = GenJs.rename(n3);
		if(GenJs.hasInScope(name22)) {
			name22 += "$" + ++GenJs.id;
		}
		GenJs.addToScope(name22);
		GenJs.parentNames.set(node,name22);
		var res = "for (const " + GenJs.rename(name22) + " of " + GenJs.stringify(a2) + ") " + GenJs.stringify(b1);
		GenJs.popScope();
		tmp = res;
		break;
	case 43:
		var b2 = node[3];
		var a3 = node[2];
		tmp = GenJs.stringify(a3) + "||" + GenJs.stringify(b2);
		break;
	case 44:
		var type = node[2];
		tmp = GenJs.extractTypeName(type);
		break;
	}
	return a + tmp;
};
GenJs.extractTypeName = function(t) {
	switch(t[1]) {
	case 0:
		var name = t[2];
		return name;
	case 1:
		var name1 = t[2];
		return name1;
	default:
		throw new js__$Boot_HaxeError("Type has no name: " + Std.string(t));
	}
};
GenJs.__super__ = GeneratorHelper;
GenJs.prototype = $extend(GeneratorHelper.prototype,{
	__class__: GenJs
});
var HxOverrides = function() { };
HxOverrides.__name__ = true;
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.iter = function(a) {
	return { cur : 0, arr : a, hasNext : function() {
		return this.cur < this.arr.length;
	}, next : function() {
		return this.arr[this.cur++];
	}};
};
var Tokens = function(tokens,length,values,lines,columns,fileName) {
	this.token = tokens;
	this.length = length;
	this.value = values;
	this.line = lines;
	this.column = columns;
	this.fileName = fileName;
};
Tokens.__name__ = true;
Tokens.prototype = {
	__class__: Tokens
};
var Lexer = function() { };
Lexer.__name__ = true;
Lexer.tokenize = function(bytes,fileName) {
	var position = 0;
	var len = bytes.length;
	var to = 0;
	var s = "";
	var p = 0;
	var line = 1;
	var columnBase = 0;
	var params = [];
	var tokens = Buffer.alloc(len + 1);
	var lines = [];
	var columns = [];
	if(len > 2 && bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) {
		position += 3;
	}
	while(position < len) {
		var _8 = 0;
		while(true) {
			_8 = bytes[position];
			if(_8 == 10) {
				++line;
				columnBase = position;
			}
			if(!(_8 <= 32 && ++position < len)) {
				break;
			}
		}
		if(position >= len) {
			break;
		}
		var _16 = len - position > 1 ? _8 | bytes[position + 1] << 8 : _8;
		if(_8 == 47) {
			if(_16 == 12079) {
				var pos = position + 2;
				while(bytes[position] != 10 && position < len) ++position;
				continue;
			}
			if(_16 == 10799 && bytes[position + 2] == 42) {
				position += 3;
				p = position;
				while(position < len) {
					var _32 = len - position > 3 ? bytes.readUInt32LE(position) : bytes[position];
					if((_32 & 255) == 10) {
						++line;
						columnBase = position;
					} else if((_32 & 16777215) == 3090986) {
						break;
					}
					++position;
				}
				if(position >= len) {
					var erline = null;
					var column = null;
					var filename = null;
					if(erline != null) {
						erline = erline;
					} else {
						erline = line;
					}
					if(column != null) {
						column = column;
					} else {
						column = position - columnBase - 1;
					}
					if(filename != null) {
						filename = filename;
					} else {
						filename = fileName;
					}
					throw new js__$Boot_HaxeError(new CompilerError(Fail.LexerError,"Unclosed doc-comment",erline,column,filename));
				}
				params[to] = bytes.toString("utf8",p,position);
				tokens[to++] = 65;
				lines.push(line);
				columns.push(position - columnBase - 1);
				position += 3;
				continue;
			}
			if(_16 == 10799) {
				var pos1 = position + 2;
				p = 0;
				position += 2;
				while(position < len) {
					if(len - position > 1) {
						_16 = bytes.readUInt16LE(position);
					} else {
						_16 = bytes[position];
					}
					if((_16 & 255) == 10) {
						++line;
						columnBase = position;
					} else if(_16 == 12074 && p > 0) {
						--p;
					} else if(_16 == 10799) {
						++p;
					} else if(_16 == 12074 && p == 0) {
						break;
					}
					++position;
				}
				position += 2;
				continue;
			}
		}
		if((_8 & 95) >= 65 && (_8 & 95) <= 90 || _8 == 95) {
			var titlechar = _8;
			p = position + 1;
			_8 = bytes[p];
			while(p < len && Lexer.isident[_8] != 0) _8 = bytes[++p];
			s = bytes.toString("ascii",position,p);
			var t;
			if((_16 & 255) <= 90) {
				t = null;
			} else {
				var _this = Lexer.kwd;
				if(__map_reserved[s] != null) {
					t = _this.getReserved(s);
				} else {
					t = _this.h[s];
				}
			}
			if(t != null) {
				tokens[to++] = t;
				lines.push(line);
				columns.push(position - columnBase - 1);
			} else if(titlechar >= 65 && titlechar <= 90) {
				params[to] = s;
				tokens[to++] = 61;
				lines.push(line);
				columns.push(position - columnBase - 1);
			} else {
				params[to] = s;
				tokens[to++] = 62;
				lines.push(line);
				columns.push(position - columnBase - 1);
			}
			position = p;
			continue;
		}
		if(_16 == 11822 && bytes[position + 2] == 46) {
			tokens[to++] = 98;
			lines.push(line);
			columns.push(position - columnBase - 1);
			position += 3;
			continue;
		}
		if(_16 == 15934 && bytes[position + 2] == 62) {
			tokens[to++] = 108;
			lines.push(line);
			columns.push(position - columnBase - 1);
			position += 3;
			continue;
		}
		var hash = (_16 & 255) + ((_16 >> 8 & 255) << 3) & 239;
		if(_16 == Lexer.op16token.readUInt16LE(hash * 2)) {
			tokens[to++] = Lexer.op16token[hash + 512];
			lines.push(line);
			columns.push(position - columnBase - 1);
			position += 2;
			continue;
		}
		var found = Lexer.ops8a[_8];
		if(found != 0) {
			tokens[to++] = found;
			lines.push(line);
			columns.push(position - columnBase - 1);
			++position;
			continue;
		}
		if(_8 < 40) {
			p = _8;
			var pos2 = ++position;
			while(bytes[position] != p && position < len) {
				if(bytes[position] == 10) {
					++line;
					columnBase = position;
				}
				if(bytes[position] == 92) {
					position += 2;
					continue;
				}
				if(len - position > 1) {
					_16 = bytes.readUInt16LE(position);
				} else {
					_16 = bytes[position];
				}
				++position;
			}
			params[to] = bytes.toString("utf8",pos2,position);
			tokens[to++] = 64;
			lines.push(line);
			columns.push(position - columnBase - 1);
			++position;
			continue;
		}
		if(_16 == 30768) {
			p = position;
			p += 2;
			_8 = bytes[position];
			while(_8 >= 65 && _8 <= 70 || _8 >= 48 && _8 <= 57 || _8 >= 97 && _8 <= 102) _8 = bytes[++p];
			if(p - position == 2) {
				var erline1 = null;
				var column1 = null;
				var filename1 = null;
				if(erline1 != null) {
					erline1 = erline1;
				} else {
					erline1 = line;
				}
				if(column1 != null) {
					column1 = column1;
				} else {
					column1 = position - columnBase - 1;
				}
				if(filename1 != null) {
					filename1 = filename1;
				} else {
					filename1 = fileName;
				}
				throw new js__$Boot_HaxeError(new CompilerError(Fail.LexerError,"Integer `0x` not allowed!",erline1,column1,filename1));
			}
			params[to] = bytes.toString("ascii",position,p);
			tokens[to++] = 63;
			lines.push(line);
			columns.push(position - columnBase - 1);
			position = p;
			continue;
		}
		if(_8 < 58) {
			p = position;
			_8 = bytes[p];
			var found1 = 63;
			while(_8 >= 48 && _8 <= 57) _8 = bytes[++p];
			if(_8 == 46 && bytes[p + 1] != 46) {
				_8 = bytes[++p];
				while(_8 >= 48 && _8 <= 57) _8 = bytes[++p];
				found1 = 60;
			}
			if(_8 == 101 || _8 == 69) {
				_8 = bytes[++p];
				if(_8 == 43 || _8 == 45) {
					_8 = bytes[++p];
				}
				while(_8 >= 48 && _8 <= 57) _8 = bytes[++p];
				found1 = 60;
			}
			params[to] = bytes.toString("ascii",position,p);
			tokens[to++] = found1;
			lines.push(line);
			columns.push(position - columnBase - 1);
			position = p;
			continue;
		}
		if(position >= len) {
			break;
		}
		var message = "Unexpected character " + String.fromCharCode(_8);
		var erline2 = null;
		var column2 = null;
		var filename2 = null;
		if(erline2 != null) {
			erline2 = erline2;
		} else {
			erline2 = line;
		}
		if(column2 != null) {
			column2 = column2;
		} else {
			column2 = position - columnBase - 1;
		}
		if(filename2 != null) {
			filename2 = filename2;
		} else {
			filename2 = fileName;
		}
		throw new js__$Boot_HaxeError(new CompilerError(Fail.LexerError,message,erline2,column2,filename2));
	}
	return new Tokens(tokens,to,params,lines,columns,fileName);
};
Lexer.init = function() {
	Lexer.isident = Buffer.alloc(256);
	var _g = 0;
	while(_g < 256) {
		var _8 = _g++;
		Lexer.isident[_8] = _8 >= 65 && _8 <= 90 || _8 >= 48 && _8 <= 57 || _8 >= 97 && _8 <= 122 || _8 == 95 ? 128 : 0;
	}
	Lexer.isUpper = Buffer.alloc(256);
	var _g1 = 0;
	while(_g1 < 256) {
		var _81 = _g1++;
		Lexer.isident[_81] = _81 >= 65 && _81 <= 90 || _81 >= 48 && _81 <= 57 || _81 >= 97 && _81 <= 122 || _81 == 95 ? 128 : 0;
	}
	Lexer.isident = Buffer.alloc(256);
	var _g2 = 0;
	while(_g2 < 256) {
		var _82 = _g2++;
		Lexer.isident[_82] = _82 >= 65 && _82 <= 90 || _82 >= 48 && _82 <= 57 || _82 >= 97 && _82 <= 122 || _82 == 95 ? 128 : 0;
	}
	var _g3 = new haxe_ds_StringMap();
	var value = 1;
	if(__map_reserved["_"] != null) {
		_g3.setReserved("_",value);
	} else {
		_g3.h["_"] = value;
	}
	var value1 = 58;
	if(__map_reserved["as"] != null) {
		_g3.setReserved("as",value1);
	} else {
		_g3.h["as"] = value1;
	}
	var value2 = 3;
	if(__map_reserved["break"] != null) {
		_g3.setReserved("break",value2);
	} else {
		_g3.h["break"] = value2;
	}
	var value3 = 4;
	if(__map_reserved["case"] != null) {
		_g3.setReserved("case",value3);
	} else {
		_g3.h["case"] = value3;
	}
	var value4 = 6;
	if(__map_reserved["catch"] != null) {
		_g3.setReserved("catch",value4);
	} else {
		_g3.h["catch"] = value4;
	}
	var value5 = 7;
	if(__map_reserved["class"] != null) {
		_g3.setReserved("class",value5);
	} else {
		_g3.h["class"] = value5;
	}
	var value6 = 8;
	if(__map_reserved["continue"] != null) {
		_g3.setReserved("continue",value6);
	} else {
		_g3.h["continue"] = value6;
	}
	var value7 = 9;
	if(__map_reserved["do"] != null) {
		_g3.setReserved("do",value7);
	} else {
		_g3.h["do"] = value7;
	}
	var value8 = 10;
	if(__map_reserved["else"] != null) {
		_g3.setReserved("else",value8);
	} else {
		_g3.h["else"] = value8;
	}
	var value9 = 11;
	if(__map_reserved["enum"] != null) {
		_g3.setReserved("enum",value9);
	} else {
		_g3.h["enum"] = value9;
	}
	var value10 = 12;
	if(__map_reserved["extends"] != null) {
		_g3.setReserved("extends",value10);
	} else {
		_g3.h["extends"] = value10;
	}
	var value11 = 13;
	if(__map_reserved["declare"] != null) {
		_g3.setReserved("declare",value11);
	} else {
		_g3.h["declare"] = value11;
	}
	var value12 = 14;
	if(__map_reserved["false"] != null) {
		_g3.setReserved("false",value12);
	} else {
		_g3.h["false"] = value12;
	}
	var value13 = 15;
	if(__map_reserved["for"] != null) {
		_g3.setReserved("for",value13);
	} else {
		_g3.h["for"] = value13;
	}
	var value14 = 16;
	if(__map_reserved["function"] != null) {
		_g3.setReserved("function",value14);
	} else {
		_g3.h["function"] = value14;
	}
	var value15 = 17;
	if(__map_reserved["if"] != null) {
		_g3.setReserved("if",value15);
	} else {
		_g3.h["if"] = value15;
	}
	var value16 = 18;
	if(__map_reserved["implements"] != null) {
		_g3.setReserved("implements",value16);
	} else {
		_g3.h["implements"] = value16;
	}
	var value17 = 19;
	if(__map_reserved["import"] != null) {
		_g3.setReserved("import",value17);
	} else {
		_g3.h["import"] = value17;
	}
	var value18 = 20;
	if(__map_reserved["in"] != null) {
		_g3.setReserved("in",value18);
	} else {
		_g3.h["in"] = value18;
	}
	var value19 = 22;
	if(__map_reserved["interface"] != null) {
		_g3.setReserved("interface",value19);
	} else {
		_g3.h["interface"] = value19;
	}
	var value20 = 23;
	if(__map_reserved["let"] != null) {
		_g3.setReserved("let",value20);
	} else {
		_g3.h["let"] = value20;
	}
	var value21 = 25;
	if(__map_reserved["new"] != null) {
		_g3.setReserved("new",value21);
	} else {
		_g3.h["new"] = value21;
	}
	var value22 = 26;
	if(__map_reserved["null"] != null) {
		_g3.setReserved("null",value22);
	} else {
		_g3.h["null"] = value22;
	}
	var value23 = 28;
	if(__map_reserved["module"] != null) {
		_g3.setReserved("module",value23);
	} else {
		_g3.h["module"] = value23;
	}
	var value24 = 29;
	if(__map_reserved["private"] != null) {
		_g3.setReserved("private",value24);
	} else {
		_g3.h["private"] = value24;
	}
	var value25 = 31;
	if(__map_reserved["return"] != null) {
		_g3.setReserved("return",value25);
	} else {
		_g3.h["return"] = value25;
	}
	var value26 = 32;
	if(__map_reserved["static"] != null) {
		_g3.setReserved("static",value26);
	} else {
		_g3.h["static"] = value26;
	}
	var value27 = 59;
	if(__map_reserved["super"] != null) {
		_g3.setReserved("super",value27);
	} else {
		_g3.h["super"] = value27;
	}
	var value28 = 33;
	if(__map_reserved["switch"] != null) {
		_g3.setReserved("switch",value28);
	} else {
		_g3.h["switch"] = value28;
	}
	var value29 = 34;
	if(__map_reserved["this"] != null) {
		_g3.setReserved("this",value29);
	} else {
		_g3.h["this"] = value29;
	}
	var value30 = 35;
	if(__map_reserved["throw"] != null) {
		_g3.setReserved("throw",value30);
	} else {
		_g3.h["throw"] = value30;
	}
	var value31 = 36;
	if(__map_reserved["true"] != null) {
		_g3.setReserved("true",value31);
	} else {
		_g3.h["true"] = value31;
	}
	var value32 = 37;
	if(__map_reserved["try"] != null) {
		_g3.setReserved("try",value32);
	} else {
		_g3.h["try"] = value32;
	}
	var value33 = 39;
	if(__map_reserved["using"] != null) {
		_g3.setReserved("using",value33);
	} else {
		_g3.h["using"] = value33;
	}
	var value34 = 40;
	if(__map_reserved["var"] != null) {
		_g3.setReserved("var",value34);
	} else {
		_g3.h["var"] = value34;
	}
	var value35 = 41;
	if(__map_reserved["while"] != null) {
		_g3.setReserved("while",value35);
	} else {
		_g3.h["while"] = value35;
	}
	var value36 = 57;
	if(__map_reserved["is"] != null) {
		_g3.setReserved("is",value36);
	} else {
		_g3.h["is"] = value36;
	}
	Lexer.kwd = _g3;
	var _g11 = new haxe_ds_IntMap();
	_g11.h[64] = 70;
	_g11.h[36] = 83;
	_g11.h[35] = 78;
	_g11.h[33] = 89;
	_g11.h[37] = 101;
	_g11.h[38] = 112;
	_g11.h[40] = 80;
	_g11.h[41] = 79;
	_g11.h[42] = 102;
	_g11.h[43] = 111;
	_g11.h[44] = 75;
	_g11.h[45] = 107;
	_g11.h[46] = 77;
	_g11.h[47] = 94;
	_g11.h[58] = 76;
	_g11.h[59] = 82;
	_g11.h[60] = 99;
	_g11.h[61] = 91;
	_g11.h[62] = 96;
	_g11.h[63] = 81;
	_g11.h[91] = 72;
	_g11.h[92] = 110;
	_g11.h[93] = 71;
	_g11.h[94] = 109;
	_g11.h[123] = 74;
	_g11.h[124] = 104;
	_g11.h[125] = 73;
	_g11.h[126] = 88;
	var ops8 = _g11;
	Lexer.ops8a = Buffer.alloc(256);
	var key = ops8.keys();
	while(key.hasNext()) {
		var key1 = key.next();
		Lexer.ops8a[key1] = ops8.h[key1];
	}
	var _g21 = new haxe_ds_IntMap();
	_g21.h[11051] = 87;
	_g21.h[11565] = 86;
	_g21.h[15420] = 105;
	_g21.h[15649] = 103;
	_g21.h[15676] = 100;
	_g21.h[15677] = 95;
	_g21.h[15678] = 97;
	_g21.h[15934] = 106;
	_g21.h[31868] = 93;
	_g21.h[9766] = 92;
	_g21.h[15933] = 90;
	_g21.h[11839] = 113;
	var ops16 = _g21;
	var key11 = ops16.keys();
	while(key11.hasNext()) {
		var key12 = key11.next();
		var key2 = ops16.keys();
		while(key2.hasNext()) {
			var key21 = key2.next();
			if(key12 != key21 && ((key12 & 255) + ((key12 >> 8 & 255) << 3) & 239) == ((key21 & 255) + ((key21 >> 8 & 255) << 3) & 239)) {
				throw new js__$Boot_HaxeError(new CompilerError(Fail.LexerError,"2-byte op hash collision: " + key12 + " " + key21,0,0,"INTERNAL"));
			}
		}
	}
	Lexer.op16token = Buffer.alloc(768);
	var key3 = ops16.keys();
	while(key3.hasNext()) {
		var key4 = key3.next();
		var hash = (key4 & 255) + ((key4 >> 8 & 255) << 3) & 239;
		Lexer.op16token.writeUInt16LE(key4,hash * 2);
		Lexer.op16token[hash + 512] = ops16.h[key4];
	}
	return;
};
Math.__name__ = true;
var OnlineCompiler = function() {
	this.last = "";
	console.log("Hexa Online Compiler");
	this.input = window.document.getElementById("editor");
	this.colored = window.document.getElementById("editorColored");
	this.output = window.document.getElementById("output");
	this.debug = window.document.getElementById("debug");
	Lexer.init();
	this.input.onkeyup = $bind(this,this.build);
	this.build();
};
OnlineCompiler.__name__ = true;
OnlineCompiler.main = function() {
	new OnlineCompiler();
};
OnlineCompiler.prototype = {
	build: function() {
		console.log("Hexaompiler");
		var code = this.input.innerText;
		if(code == this.last) {
			return;
		}
		this.last = code;
		var content = Buffer.from(code);
		var result = "";
		this.output.innerHTML = "1";
		this.debug.innerHTML = "2";
		try {
			var tokens = Lexer.tokenize(content,"main.hexa");
			var parser = new Parser(tokens);
			var collected = Node.TBlock([parser.node]);
			Typer.fillScopes(collected);
			result = GenJs.stringify(collected);
		} catch( $e0 ) {
			if ($e0 instanceof js__$Boot_HaxeError) $e0 = $e0.val;
			if( js_Boot.__instanceof($e0,CompilerError) ) {
				var e = $e0;
				console.log("CompilerError");
				console.log(e);
				console.log("!!!");
				var tmp = e.toString();
				this.output.innerHTML = "Error: " + tmp;
				this.debug.innerHTML = "Fix errors to run the code!";
				return;
			} else {
			var e1 = $e0;
			var tmp1 = Std.string(e1.toString());
			this.output.innerHTML = "" + tmp1;
			this.debug.innerHTML = "Fix errors to run the code!";
			return;
			}
		}
		this.style();
		var html = result;
		html = html.split(" ").join("&nbsp;");
		html = html.split("\t").join("&nbsp;&nbsp;&nbsp;&nbsp;");
		html = html.split("\r\n").join("<br/>");
		html = html.split("\n").join("<br/>");
		this.output.innerHTML = "// JavaScript from Hexa<br/>" + html;
		this.debug.innerHTML = "";
		try {
			eval(result.split("console").join("$console"));
		} catch( e2 ) {
			if (e2 instanceof js__$Boot_HaxeError) e2 = e2.val;
			this.debug.innerHTML = "" + Std.string(e2);
		}
	}
	,style: function() {
		return;
	}
	,__class__: OnlineCompiler
};
var Parser = function(lexe) {
	this.parametricTypeNestingToken = 0;
	this.parametricTypeNesting = 0;
	this.class_external = false;
	this.lasttokchecks = 10;
	this.lasttok = -1;
	this.i = 0;
	this.atts = [];
	this.lex = lexe;
	var el = [];
	while(this.i < this.lex.length && this.tok() != 0) el.push(this.parseExpr());
	this.node = el[0];
	if(el.length == 0) {
		this.node = null;
	}
	if(el.length > 1) {
		this.node = Node.TBlock(el);
	}
	if(this.atts.length > 0) {
		process.stdout.write("\n");
		throw new js__$Boot_HaxeError(this.fail("Not all attributes conceived"));
	}
};
Parser.__name__ = true;
Parser.isBinop = function(t) {
	switch(t) {
	case 91:case 92:case 93:case 94:case 95:case 96:case 97:case 99:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 111:case 112:
		return true;
	default:
		return false;
	}
};
Parser.prototype = {
	parseFields: function() {
		var fields = [];
		while(this.tok() != 73) {
			while(this.tok() == 70) this.parseAttribute();
			var _static = false;
			if(this.tok() == 32) {
				_static = true;
				this.i++;
			}
			var _g = this.tok();
			switch(_g) {
			case 25:
				this.i++;
				var expr = null;
				var vars = [];
				var types = [];
				var values = [];
				this.step(80);
				while(this.tok() != 79) {
					vars.push(this.getgo(62));
					if(this.tok() == 76) {
						this.i++;
						types.push(this.parseType());
					}
					if(this.tok() == 91) {
						this.i++;
						values.push(this.parseExpr());
					}
					if(this.tok() == 75) {
						this.i++;
					}
				}
				this.step(79);
				if(this.tok() != 73) {
					expr = this.parseExpr();
				}
				var v = [];
				var _g1 = 0;
				var _g2 = vars.length;
				while(_g1 < _g2) {
					var i = _g1++;
					v.push(Node.TVar(vars[i],types[i],values[i],true));
				}
				fields.push(Node.TFunction("new",expr,v,null));
				break;
			case 29:
				this.i++;
				break;
			case 16:case 23:case 40:
				var f = this.parseExpr();
				if(_static) {
					f = Node.TStatic(f);
				}
				fields.push(f);
				break;
			default:
				console.log("\n\nparseFields " + _$Token_Token_$Impl_$.stringify(this.tok()));
				throw new js__$Boot_HaxeError(this.fail("KClass"));
			}
		}
		return fields;
	}
	,tok: function() {
		if(this.i > this.lex.length) {
			console.log("Parser is out of token space!");
			console.log("This should NOT happen.");
			console.log("Please, issue a developer (with a code sample).");
			throw new js__$Boot_HaxeError(this.fail(this.lex.fileName + ": Parser Internal Error: Out of token space"));
		}
		var t = this.lex.token[this.i];
		if(this.lasttok != this.i) {
			this.lasttok = this.i;
			this.lasttokchecks = 40;
		} else {
			this.lasttokchecks--;
			if(this.lasttokchecks < 0) {
				throw new js__$Boot_HaxeError(this.fail("Parser Internal Error: Same token parsed too many times: " + ("`" + this.print() + "`")));
			}
		}
		return t;
	}
	,print: function() {
		return _$Token_Token_$Impl_$.stringify(this.lex.token[this.i],this.lex.value[this.i]);
	}
	,expect: function(t) {
		if(t != this.tok()) {
			this.expected(_$Token_Token_$Impl_$.stringify(t));
		}
	}
	,fail: function(message,line,column,filename) {
		if(line != null) {
			line = line;
		} else {
			line = this.lex.line[this.i];
		}
		if(column != null) {
			column = column;
		} else {
			column = this.lex.column[this.i];
		}
		if(filename != null) {
			filename = filename;
		} else {
			filename = this.lex.fileName;
		}
		return new CompilerError(Fail.ParserError,message,line,column,filename);
	}
	,getgo: function(t) {
		this.expect(t);
		return this.lex.value[this.i++];
	}
	,step: function(t) {
		this.expect(t);
		this.i++;
	}
	,unexpected: function() {
		var token = _$Token_Token_$Impl_$.stringify(this.lex.token[this.i],this.lex.value[this.i]);
		if(this.tok() == 82) {
			console.log("Note, that Hexa has no semicolons!");
		}
		throw new js__$Boot_HaxeError(this.fail("Unexpected `" + token + "`"));
	}
	,expected: function(str) {
		var token = _$Token_Token_$Impl_$.stringify(this.lex.token[this.i],this.lex.value[this.i]);
		throw new js__$Boot_HaxeError(this.fail("Expected `" + str + "` before `" + token + "`"));
	}
	,parseExpr: function() {
		while(this.tok() == 70) this.parseAttribute();
		var node = this.tok();
		var nodePosition_line;
		var nodePosition_column;
		nodePosition_line = this.lex.line[this.i];
		nodePosition_column = this.lex.column[this.i];
		var result;
		switch(node) {
		case 1:
			this.i++;
			result = Node.TUnderscore;
			break;
		case 3:
			this.i++;
			result = Node.TBreak;
			break;
		case 7:case 22:
			var att = this.atts;
			this.atts = [];
			this.i++;
			var t = this.parseType();
			var ext;
			if(this.tok() == 12) {
				this.i++;
				ext = this.parseType();
			} else {
				ext = null;
			}
			var impl = [];
			while(this.tok() == 18) {
				this.i++;
				impl.push(this.parseType());
			}
			this.step(74);
			var fields = this.parseFields();
			this.step(73);
			var me = Node.TClass(t,ext,impl,fields,this.class_external);
			Project.mapAttributes.set(me,att);
			result = me;
			break;
		case 8:
			this.i++;
			result = Node.TContinue;
			break;
		case 9:
			this.i++;
			var e = this.parseExpr();
			this.step(41);
			this.step(80);
			var econd = this.parseExpr();
			this.step(79);
			result = Node.TWhile(econd,e,false);
			break;
		case 11:
			this.i++;
			var t1 = this.parseType();
			if(this.tok() == 76) {
				this.i++;
				this.parseType();
			}
			this.step(74);
			var names = [];
			while(this.tok() != 73) {
				while(this.tok() == 70) this.parseAttribute();
				this.atts = [];
				names.push(this.parseExpr());
			}
			this.step(73);
			result = Node.TEnum(t1,names);
			break;
		case 13:
			this.i++;
			var e1;
			var _g = this.tok();
			switch(_g) {
			case 16:
				e1 = this.parseFunction(false);
				break;
			case 61:
				var left = this.parseType();
				this.step(91);
				e1 = Node.TBinop(91,Node.NodeTypeValue(left),Node.NodeTypeValue(this.parseType()));
				break;
			default:
				e1 = this.parseExpr();
			}
			var name = null;
			var extracted;
			switch(e1[1]) {
			case 39:
				var el = e1[2];
				extracted = el;
				break;
			case 40:
				var el1 = e1[2];
				extracted = el1;
				break;
			case 41:
				var el2 = e1[2];
				extracted = el2;
				break;
			default:
				extracted = e1;
			}
			switch(extracted[1]) {
			case 8:
				if(extracted[2] == 91) {
					switch(extracted[3][1]) {
					case 1:
						var n = extracted[3][2];
						name = n;
						break;
					case 44:
						switch(extracted[3][2][1]) {
						case 0:
							var n1 = extracted[3][2][2];
							name = n1;
							break;
						case 1:
							var n2 = extracted[3][2][2];
							name = n2;
							break;
						default:
							throw new js__$Boot_HaxeError(this.fail("Incorrect `declare` syntax! Use `declare let name:T` or `declare function name():T`"));
						}
						break;
					default:
						throw new js__$Boot_HaxeError(this.fail("Incorrect `declare` syntax! Use `declare let name:T` or `declare function name():T`"));
					}
				} else {
					throw new js__$Boot_HaxeError(this.fail("Incorrect `declare` syntax! Use `declare let name:T` or `declare function name():T`"));
				}
				break;
			case 19:
				var e2 = extracted[3];
				var n3 = extracted[2];
				if(n3 == null) {
					throw new js__$Boot_HaxeError(this.fail("Function in `declare` should have a name"));
				} else if(e2 == null) {
					name = n3;
				} else {
					throw new js__$Boot_HaxeError(this.fail("Functions in `declare` should *not* have a body"));
				}
				break;
			case 20:
				var e3 = extracted[4];
				var t2 = extracted[3];
				var n4 = extracted[2];
				if(t2 == null) {
					throw new js__$Boot_HaxeError(this.fail("Variable `" + n4 + "` in `declare` should have a type"));
				} else if(e3 == null) {
					name = n4;
				} else {
					throw new js__$Boot_HaxeError(this.fail("Variable `" + n4 + "` in `declare` should *not* have a value"));
				}
				break;
			case 21:
				throw new js__$Boot_HaxeError(this.fail("Place only one variable into `declare`"));
				break;
			case 22:
				switch(extracted[2][1]) {
				case 0:
					var n5 = extracted[2][2];
					name = n5;
					break;
				case 1:
					var n6 = extracted[2][2];
					name = n6;
					break;
				default:
					throw new js__$Boot_HaxeError(this.fail("Incorrect `declare` syntax! Use `declare let name:T` or `declare function name():T`"));
				}
				break;
			default:
				throw new js__$Boot_HaxeError(this.fail("Incorrect `declare` syntax! Use `declare let name:T` or `declare function name():T`"));
			}
			result = Node.TDeclare(name,e1);
			break;
		case 14:
			this.i++;
			result = Node.TBool(false);
			break;
		case 15:
			this.i++;
			this.step(80);
			var n7 = this.getgo(62);
			this.step(20);
			var a = this.parseExpr();
			this.step(79);
			var b = this.parseExpr();
			result = Node.TFor(n7,a,b);
			break;
		case 16:
			result = this.parseFunction();
			break;
		case 17:
			this.i++;
			this.step(80);
			var econd1 = [this.parseExpr()];
			while(this.tok() == 75) {
				this.i++;
				econd1.push(this.parseExpr());
			}
			this.step(79);
			var eif = null;
			if(this.tok() != 76) {
				eif = this.parseExpr();
			}
			var eelse = null;
			if(this.tok() == 10) {
				this.i++;
				eelse = this.parseExpr();
			}
			result = Node.TIf(econd1,eif,eelse);
			break;
		case 23:case 40:
			var parsed = this.parseVar();
			if(parsed.length > 1) {
				result = Node.TVars(parsed);
			} else {
				result = parsed[0];
			}
			break;
		case 25:
			this.i++;
			var t3 = this.parseType();
			var names1 = [];
			var values = [];
			if(this.tok() == 74) {
				this.i++;
				if(this.tok() == 76) {
					this.i++;
					this.step(73);
				} else if(this.tok() == 62 && this.lex.token[this.i + 1] == 76) {
					while(this.tok() != 73) {
						names1.push(this.getgo(62));
						this.step(76);
						values.push(this.parseExpr());
						if(this.tok() == 75) {
							this.i++;
						}
					}
					this.step(73);
				} else if(this.tok() == 73) {
					this.step(73);
				}
			}
			this.step(80);
			var args = [];
			while(this.tok() != 79) {
				args.push(this.parseExpr());
				if(this.tok() == 75) {
					this.i++;
				}
			}
			this.step(79);
			result = Node.TNew(t3,args,names1,values);
			break;
		case 26:
			this.i++;
			result = Node.TNull;
			break;
		case 28:
			this.i++;
			var path = [];
			if(this.tok() == 62) {
				path.push(this.getgo(62));
				while(this.tok() == 77) {
					this.i++;
					path.push(this.getgo(62));
				}
			}
			this.step(74);
			var el3 = [];
			while(this.tok() != 73) el3.push(this.parseExpr());
			this.step(73);
			result = Node.TModule(path,el3);
			break;
		case 29:
			this.i++;
			result = Node.TPrivate(this.parseExpr());
			break;
		case 31:
			this.i++;
			var _g1 = this.tok();
			switch(_g1) {
			case 40:case 73:
				result = Node.TReturn(null);
				break;
			default:
				result = Node.TReturn(this.parseExpr());
			}
			break;
		case 32:
			this.i++;
			result = Node.TStatic(this.parseExpr());
			break;
		case 33:
			this.i++;
			this.step(80);
			var exprs = [];
			while(this.tok() != 79) {
				exprs.push(this.parseExpr());
				if(this.tok() == 75) {
					this.i++;
				}
			}
			this.step(79);
			this.step(74);
			var cases = [];
			var conds = [];
			while(this.tok() != 73) {
				this.step(4);
				var cond = [];
				while(this.tok() != 76) {
					if(this.tok() == 1) {
						this.i++;
						cond.push(Node.TUnderscore);
					} else {
						cond.push(this.parseExpr());
					}
					if(this.tok() == 75) {
						this.i++;
					}
				}
				conds.push(cond);
				this.step(76);
				var exs = [];
				while(this.tok() != 4 && this.tok() != 73) exs.push(this.parseExpr());
				cases.push(Node.TBlock(exs));
			}
			this.step(73);
			result = Node.TSwitch(exprs,conds,cases);
			break;
		case 34:
			this.i++;
			result = Node.TThis;
			break;
		case 35:
			this.i++;
			result = Node.TThrow(this.parseExpr());
			break;
		case 36:
			this.i++;
			result = Node.TBool(true);
			break;
		case 37:
			this.i++;
			var expr = this.parseExpr();
			var vars = [];
			var t4 = [];
			var v = [];
			var catches = [];
			while(this.tok() == 6) {
				this.step(6);
				this.step(80);
				var name1 = this.getgo(62);
				vars.push(name1);
				this.step(76);
				var type = this.parseType();
				t4.push(type);
				v.push(Node.TVar(name1,type,null,true));
				this.step(79);
				catches.push(this.parseExpr());
			}
			result = Node.TTry(expr,t4,v,catches);
			break;
		case 39:
			this.i++;
			var names2 = [this.getgo(61)];
			while(this.tok() == 75) {
				this.step(75);
				names2.push(this.getgo(61));
			}
			result = Node.TUsing(names2);
			break;
		case 41:
			this.i++;
			this.step(80);
			var econd2 = this.parseExpr();
			this.step(79);
			var e4 = this.parseExpr();
			result = Node.TWhile(econd2,e4,true);
			break;
		case 59:
			this.i++;
			result = Node.TSuper;
			break;
		case 60:
			result = Node.TFloat(this.getgo(60));
			break;
		case 61:
			if(this.lex.token[this.i + 1] == 99) {
				var res = this.parseType();
				result = Node.NodeTypeValue(res);
			} else {
				var name2 = this.getgo(61);
				result = Node.TIdent(name2);
			}
			break;
		case 62:
			var name3 = this.getgo(62);
			result = Node.TIdent(name3);
			break;
		case 63:
			result = Node.TInt(this.getgo(63));
			break;
		case 64:
			var str = this.getgo(64);
			if(this.hasInterpolation(str)) {
				result = Node.TParenthesis(this.parseInterpolations(str));
			} else {
				result = Node.TString(str);
			}
			break;
		case 72:
			this.i++;
			var el4 = [];
			var values1 = [];
			var isMap = false;
			while(this.tok() != 71) {
				if(this.tok() == 76) {
					isMap = true;
					this.i++;
					break;
				}
				el4.push(this.parseExpr());
				if(this.tok() == 76) {
					this.i++;
					values1.push(this.parseExpr());
					isMap = true;
				}
				if(this.tok() == 75) {
					this.i++;
				}
			}
			this.step(71);
			if(isMap) {
				result = Node.TMap(el4,values1);
			} else {
				result = Node.TArray(el4);
			}
			break;
		case 74:
			this.i++;
			if(this.tok() == 73) {
				this.i++;
				result = Node.TBlock([]);
			} else if(this.tok() == 76) {
				this.i++;
				this.step(73);
				result = Node.TObject([],[]);
			} else if(this.tok() == 62 && this.lex.token[this.i + 1] == 76) {
				var names3 = [];
				var el5 = [];
				while(this.tok() != 73) {
					names3.push(this.getgo(62));
					this.step(76);
					el5.push(this.parseExpr());
					if(this.tok() == 75) {
						this.i++;
					}
				}
				this.step(73);
				result = Node.TObject(names3,el5);
			} else {
				var el6 = [];
				while(this.tok() != 73) el6.push(this.parseExpr());
				this.step(73);
				result = Node.TBlock(el6);
			}
			break;
		case 80:
			this.i++;
			if(this.tok() == 79 && this.lex.token[this.i + 1] == 90 || this.tok() == 62 && this.lex.token[this.i + 1] == 75 || this.tok() == 62 && this.lex.token[this.i + 1] == 76 || this.tok() == 62 && this.lex.token[this.i + 1] == 79 && this.lex.token[this.i + 2] == 90) {
				var vars1 = [];
				var types = [];
				var values2 = [];
				while(this.tok() != 79) {
					vars1.push(this.getgo(62));
					if(this.tok() == 76) {
						this.i++;
						types.push(this.parseType());
					}
					if(this.tok() == 91) {
						this.i++;
						values2.push(this.parseExpr());
					}
					if(this.tok() == 75) {
						this.i++;
					}
				}
				this.step(79);
				this.step(90);
				var v1 = [];
				var _g11 = 0;
				var _g2 = vars1.length;
				while(_g11 < _g2) {
					var i = _g11++;
					v1.push(Node.TVar(vars1[i],types[i],values2[i],true));
				}
				result = Node.TFunction(null,this.parseExpr(),v1,null);
			} else {
				var expr1 = this.parseExpr();
				this.step(79);
				result = Node.TParenthesis(expr1);
			}
			break;
		case 86:
			this.i++;
			result = Node.TUnop(86,false,this.parseExpr());
			break;
		case 87:
			this.i++;
			result = Node.TUnop(87,false,this.parseExpr());
			break;
		case 88:
			this.i++;
			result = Node.TUnop(88,false,this.parseExpr());
			break;
		case 89:
			this.i++;
			result = Node.TUnop(89,false,this.parseExpr());
			break;
		case 98:
			this.i++;
			result = Node.TUnop(98,false,this.parseExpr());
			break;
		case 107:
			this.i++;
			result = Node.TUnop(107,false,this.parseExpr());
			break;
		default:
			this.unexpected();
			result = null;
		}
		if(result == null) {
			process.stdout.write("\n");
			throw new js__$Boot_HaxeError(this.fail("Expression is incomplete, current tokens is: " + _$Token_Token_$Impl_$.stringify(this.tok())));
		}
		if(this.atts.length > 0) {
			Project.mapAttributes.set(result,this.atts);
			this.atts = [];
		}
		var done = false;
		while(!done) {
			var _g3 = this.tok();
			switch(_g3) {
			case 57:
				this.i++;
				var _g4 = this.tok();
				if(_g4 == 61) {
					result = Node.TIs(result,this.parseType());
				} else {
					throw new js__$Boot_HaxeError(this.fail("Cannot parse type `" + _$Token_Token_$Impl_$.stringify(this.tok()) + "`"));
				}
				break;
			case 58:
				this.i++;
				var kind = this.tok();
				if(this.tok() == 89) {
					this.i++;
				} else if(this.tok() == 81) {
					this.i++;
				} else {
					kind = 123;
				}
				result = Node.TAs(result,kind,this.parseType());
				break;
			case 72:
				this.i++;
				var index = this.parseExpr();
				this.step(71);
				result = Node.TIndex(result,index);
				break;
			case 77:
				this.i++;
				var name4;
				var _g5 = this.tok();
				if(_g5 == 61) {
					name4 = this.getgo(61);
				} else {
					name4 = this.getgo(62);
				}
				result = Node.TDot(result,name4);
				break;
			case 80:
				var args1 = [];
				var argNames = [];
				this.i++;
				while(this.tok() != 79) {
					var argname = null;
					var _g6 = this.tok();
					if(_g6 == 61) {
						args1.push(this.parseExpr());
						if(this.tok() == 76) {
							this.step(76);
							this.parseType();
						}
					} else {
						if(this.lex.token[this.i + 1] == 76) {
							argNames.push(this.getgo(62));
							this.step(76);
						} else {
							argNames.push(null);
						}
						args1.push(this.parseExpr());
					}
					if(this.tok() != 79) {
						this.step(75);
					}
				}
				this.step(79);
				result = Node.TCall(result,args1,argNames);
				break;
			case 81:
				this.i++;
				if(this.tok() == 77) {
					var name5 = this.getgo(62);
					result = Node.TDot(result,name5);
				} else if(this.tok() == 81) {
					this.i++;
					result = Node.TElvis(result,this.parseExpr());
				} else {
					var eif1 = this.parseExpr();
					this.step(76);
					var eelse1 = this.parseExpr();
					result = Node.TIf([result],eif1,eelse1);
				}
				break;
			case 86:
				this.i++;
				result = Node.TUnop(86,true,result);
				break;
			case 87:
				this.i++;
				result = Node.TUnop(87,true,result);
				break;
			case 90:
				this.i++;
				result = Node.TFunction(null,this.parseExpr(),[result],null);
				break;
			case 113:
				this.i++;
				result = this.parseExpr();
				break;
			default:
				var t5 = _g3;
				if(Parser.isBinop(t5)) {
					this.i++;
					if(this.tok() == 91) {
						this.i++;
					}
					var b1 = this.parseExpr();
					var a1 = result;
					if(b1[1] == 8) {
						var bb = b1[4];
						var aa = b1[3];
						var op = b1[2];
						var tp = this.precedence(t5);
						var tLeft = tp > 99;
						tp %= 100;
						var bp = this.precedence(op);
						var bLeft = bp > 99;
						bp %= 100;
						if(bp > tp) {
							result = Node.TBinop(op,Node.TBinop(t5,result,aa),bb);
						} else {
							result = Node.TBinop(t5,result,b1);
						}
					} else {
						result = Node.TBinop(t5,result,b1);
					}
				} else {
					done = true;
					result = result;
				}
			}
		}
		if(result == null) {
			process.stdout.write("\n");
			throw new js__$Boot_HaxeError(this.fail("Expression postfix is incomplete"));
		}
		if(this.atts.length > 0) {
			Project.mapAttributes.set(result,this.atts);
			this.atts = [];
		}
		Project.data.set(result,new NodeData(nodePosition_line,nodePosition_column,this.lex.fileName));
		return result;
	}
	,parseVar: function() {
		var $const = this.tok() == 23;
		this.i++;
		var vars = [];
		var _g = this.tok();
		switch(_g) {
		case 61:
			var left = Node.TIdent(this.getgo(61));
			var res = left;
			while(this.tok() == 77) res = Node.TDot(res,this.getgo(61));
			var _g1 = this.tok();
			switch(_g1) {
			case 80:
				var args = [];
				while(this.tok() != 79) args.push(this.getgo(62));
				this.step(91);
				var varname = this.getgo(62);
				vars.push(Node.TEnumExtract(res,args,varname));
				break;
			case 91:
				break;
			default:
				throw new js__$Boot_HaxeError(this.fail("Wrong syntax"));
			}
			break;
		case 62:
			while(true) {
				var varname1 = this.getgo(62);
				if(StringTools.endsWith(varname1,"___")) {
					throw new js__$Boot_HaxeError(this.fail("Variables can't end with `___`, it is reserved."));
				}
				var type = null;
				if(this.tok() == 76) {
					this.i++;
					type = this.parseType();
				}
				var expr = null;
				if(this.tok() == 91) {
					this.i++;
					expr = this.parseExpr();
				}
				vars.push(Node.TVar(varname1,type,expr,$const));
				if(this.tok() == 75 && this.lex.token[this.i + 1] == 62 && (this.lex.token[this.i + 2] == 91 || this.lex.token[this.i + 2] == 76)) {
					this.i++;
				} else {
					break;
				}
			}
			break;
		default:
			throw new js__$Boot_HaxeError(this.fail("Wrong syntax"));
		}
		return vars;
	}
	,parseFunction: function(parseBody) {
		if(parseBody != null) {
			parseBody = parseBody;
		} else {
			parseBody = true;
		}
		this.i++;
		var expr = null;
		var name = null;
		var vars = [];
		var types = [];
		var values = [];
		var _g = this.tok();
		switch(_g) {
		case 61:
			throw new js__$Boot_HaxeError(this.fail("Function names can't start with uppercase."));
			break;
		case 62:
			name = this.getgo(62);
			break;
		default:
		}
		this.step(80);
		while(this.tok() != 79) {
			var expr1 = null;
			var t = null;
			if(this.tok() == 98) {
				this.i++;
			}
			var name1 = this.getgo(62);
			if(this.tok() == 76) {
				this.i++;
				t = this.parseType();
			}
			if(this.tok() == 91) {
				this.i++;
				expr1 = this.parseExpr();
			}
			vars.push(name1);
			types.push(t);
			values.push(expr1);
			if(this.tok() == 75) {
				this.i++;
			}
		}
		this.step(79);
		var rettype = null;
		if(this.tok() == 76) {
			this.i++;
			rettype = this.parseType();
		}
		var _g1 = this.tok();
		switch(_g1) {
		case 25:
			if(this.lex.token[this.i + 1] != 80) {
				if(parseBody) {
					expr = this.parseExpr();
				}
			}
			break;
		case 16:case 29:case 32:case 73:
			break;
		default:
			if(parseBody) {
				expr = this.parseExpr();
			}
		}
		var v = [];
		var _g3 = 0;
		var _g2 = vars.length;
		while(_g3 < _g2) {
			var i = _g3++;
			v.push(Node.TVar(vars[i],types[i],values[i],true));
		}
		return Node.TFunction(name,expr,v,rettype);
	}
	,hasInterpolation: function(str) {
		var chars = str.split("");
		var i = 0;
		while(i < chars.length) {
			if(chars[i] == "\\") {
				if(i + 1 < chars.length) {
					if(chars[i + 1] == "\\") {
						++i;
					} else if(chars[i + 1] == "(") {
						return true;
					}
				}
			}
			++i;
		}
		return false;
	}
	,parseInterpolations: function(str) {
		var chars = str.split("");
		var resStr = "\"";
		var i = 0;
		var inScopes = false;
		var scopes = "";
		var scopeCount = 0;
		while(i < chars.length) {
			var $char = chars[i];
			switch($char) {
			case "\"":
				resStr += "\\\"";
				++i;
				continue;
				break;
			case "(":
				if(inScopes) {
					++scopeCount;
				}
				break;
			case ")":
				if(scopeCount > 0) {
					--scopeCount;
				} else {
					resStr += scopes + ") + \"";
					inScopes = false;
					scopes = "";
					++i;
					continue;
				}
				break;
			case "\\":
				if(i + 1 < chars.length) {
					if(chars[i + 1] == "\\") {
						++i;
						$char += "\\";
					} else if(chars[i + 1] == "(") {
						inScopes = true;
						resStr += "\" + (";
						i += 2;
						continue;
					}
				}
				break;
			default:
			}
			if(inScopes) {
				scopes += $char;
			} else {
				resStr += $char;
			}
			++i;
		}
		resStr += "\"";
		var tokens = Lexer.tokenize(Buffer.from(resStr),"");
		try {
			var parsed = new Parser(tokens);
			var _g = parsed.node;
			switch(_g[1]) {
			case 9:
				throw new js__$Boot_HaxeError(null);
				break;
			case 12:
				if(_g[2][1] == 9) {
					throw new js__$Boot_HaxeError(null);
				} else {
					return parsed.node;
				}
				break;
			default:
				return parsed.node;
			}
		} catch( e ) {
			if (e instanceof js__$Boot_HaxeError) e = e.val;
			throw new js__$Boot_HaxeError(this.fail("Parse interpolation error: " + Std.string(e)));
		}
	}
	,parseAttribute: function() {
		this.i++;
		var name = this.getgo(62);
		var values = [];
		if(this.tok() == 80) {
			this.i++;
			while(this.tok() != 79) {
				values.push(this.parseExpr());
				if(this.tok() == 75) {
					this.i++;
				}
			}
			this.step(79);
		}
		this.atts.push({ name : name, values : values});
	}
	,parseType: function() {
		var result;
		var _g = this.tok();
		switch(_g) {
		case 61:
			var name = this.getgo(61);
			while(this.tok() == 77) {
				this.i++;
				this.getgo(61);
			}
			var result1;
			if(this.tok() == 99) {
				this.i++;
				this.parametricTypeNesting++;
				var params = [this.parseType()];
				while(this.tok() == 75) {
					this.i++;
					params.push(this.parseType());
				}
				if(this.parametricTypeNestingToken == 0) {
					this.parametricTypeNestingToken = this.tok();
				}
				var _g1 = this.parametricTypeNestingToken;
				switch(_g1) {
				case 96:
					this.parametricTypeNesting -= 1;
					this.parametricTypeNestingToken = 0;
					this.i++;
					break;
				case 106:
					this.parametricTypeNesting -= 1;
					this.parametricTypeNestingToken = 96;
					break;
				case 108:
					this.parametricTypeNesting -= 1;
					this.parametricTypeNestingToken = 108;
					break;
				default:
					this.unexpected();
				}
				if(this.parametricTypeNesting < 0) {
					throw new js__$Boot_HaxeError(this.fail("parametricTypeNesting < 0"));
				}
				result1 = NodeType.ParamentricType(name,params);
			} else {
				result1 = NodeType.Type(name);
			}
			if(this.tok() == 90) {
				this.i++;
				result1 = NodeType.Function([result1],this.parseType());
			}
			result = result1;
			break;
		case 62:
			var res;
			var _g2 = this.lex.token[this.i + 1];
			switch(_g2) {
			case 76:
				var argName = this.getgo(this.tok());
				this.step(76);
				var argType = this.parseType();
				res = NodeType.FunctionArg(argName,argType,null);
				break;
			case 77:
				this.i += 2;
				res = this.parseType();
				break;
			default:
				throw new js__$Boot_HaxeError(this.fail("Typename can not start with lowercase"));
			}
			result = res;
			break;
		case 72:
			this.i++;
			var res1 = null;
			var _g3 = this.tok();
			switch(_g3) {
			case 71:
				this.i++;
				res1 = NodeType.ParamentricType("Array",[NodeType.Object([],[])]);
				break;
			case 76:
				this.i++;
				if(this.tok() == 71) {
					this.i++;
					res1 = NodeType.ParamentricType("Map",[NodeType.Object([],[]),NodeType.Object([],[])]);
				} else {
					res1 = NodeType.ParamentricType("Map",[NodeType.Object([],[]),this.parseType()]);
				}
				break;
			default:
				var key = this.parseType();
				var innerRes;
				if(this.tok() == 76) {
					this.i++;
					innerRes = NodeType.ParamentricType("Map",[key,this.parseType()]);
				} else {
					innerRes = NodeType.ParamentricType("Array",[key]);
				}
				this.step(71);
				if(this.tok() == 90) {
					this.i++;
					innerRes = NodeType.Function([res1],this.parseType());
				}
				res1 = innerRes;
			}
			result = res1;
			break;
		case 74:
			this.i++;
			var result2;
			if(this.tok() == 76) {
				this.i++;
				result2 = NodeType.Object([],[]);
			} else {
				var names = [];
				var types = [];
				while(this.tok() != 73) {
					names.push(this.getgo(62));
					if(this.tok() == 76) {
						this.i++;
						types.push(this.parseType());
					}
					if(this.tok() == 75) {
						this.i++;
					}
				}
				result2 = NodeType.Object(names,types);
			}
			this.step(73);
			if(this.tok() == 90) {
				this.i++;
				result2 = NodeType.Function([result2],this.parseType());
			}
			result = result2;
			break;
		case 80:
			this.i++;
			var args = [];
			while(this.tok() != 79) {
				this.parseType();
				if(this.tok() == 76) {
					this.i++;
					args.push(this.parseType());
				}
				if(this.tok() == 75) {
					this.i++;
				}
			}
			this.step(79);
			this.step(90);
			result = NodeType.Function(args,this.parseType());
			break;
		default:
			throw new js__$Boot_HaxeError(this.fail("Excected Type, parsed `" + _$Token_Token_$Impl_$.stringify(this.tok()) + "`"));
		}
		while(this.tok() == 81) this.i++;
		if(this.tok() == 90) {
			this.i++;
			result = NodeType.Function([result],this.parseType());
		}
		return result;
	}
	,precedence: function(op) {
		var left = 100;
		var right = 0;
		switch(op) {
		case 91:
			return 10 + right;
		case 92:
			return 7 + left;
		case 93:
			return 8 + left;
		case 95:case 96:case 97:case 99:case 100:case 103:
			return 5 + left;
		case 101:
			return left;
		case 94:case 102:
			return 1 + left;
		case 105:case 106:case 108:
			return 3 + left;
		case 107:case 111:
			return 2 + left;
		case 104:case 109:case 112:
			return 4 + left;
		default:
			throw new js__$Boot_HaxeError(this.fail("No precedence for " + _$Token_Token_$Impl_$.stringify(op)));
		}
	}
	,__class__: Parser
};
var Std = function() { };
Std.__name__ = true;
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
var StringTools = function() { };
StringTools.__name__ = true;
StringTools.endsWith = function(s,end) {
	var elen = end.length;
	var slen = s.length;
	if(slen >= elen) {
		return HxOverrides.substr(s,slen - elen,elen) == end;
	} else {
		return false;
	}
};
var _$Token_Token_$Impl_$ = {};
_$Token_Token_$Impl_$.__name__ = true;
_$Token_Token_$Impl_$.stringify = function(this1,param) {
	var token = this1;
	switch(token) {
	case 0:
		return "<!--eof-->";
	case 1:
		return "_";
	case 3:
		return "break";
	case 4:
		return "case";
	case 6:
		return "catch";
	case 7:
		return "class";
	case 8:
		return "continue";
	case 9:
		return "do";
	case 10:
		return "else";
	case 11:
		return "enum";
	case 12:
		return "extends";
	case 13:
		return "declare";
	case 14:
		return "false";
	case 15:
		return "for";
	case 16:
		return "function";
	case 17:
		return "if";
	case 18:
		return "implements";
	case 19:
		return "import";
	case 20:
		return "in";
	case 22:
		return "interface";
	case 23:
		return "let";
	case 25:
		return "new";
	case 26:
		return "null";
	case 28:
		return "module";
	case 29:
		return "private";
	case 31:
		return "return";
	case 32:
		return "static";
	case 33:
		return "switch";
	case 34:
		return "this";
	case 35:
		return "throw";
	case 36:
		return "true";
	case 37:
		return "try";
	case 39:
		return "using";
	case 40:
		return "var";
	case 41:
		return "while";
	case 57:
		return "is";
	case 58:
		return "as";
	case 59:
		return "super";
	case 60:
		if(param == null) {
			return "float";
		} else {
			return param;
		}
		break;
	case 61:
		if(param == null) {
			return "upper";
		} else {
			return param;
		}
		break;
	case 62:
		if(param == null) {
			return "lower";
		} else {
			return param;
		}
		break;
	case 63:
		if(param == null) {
			return "integer";
		} else {
			return param;
		}
		break;
	case 64:
		if(param == null) {
			return "string";
		} else {
			return "'" + param + "'";
		}
		break;
	case 65:
		return "///" + param;
	case 70:
		return "@";
	case 71:
		return "]";
	case 72:
		return "[";
	case 73:
		return "}";
	case 74:
		return "{";
	case 75:
		return ",";
	case 76:
		return ":";
	case 77:
		return ".";
	case 78:
		return "#";
	case 79:
		return ")";
	case 80:
		return "(";
	case 81:
		return "?";
	case 82:
		return ";";
	case 83:
		return "$";
	case 86:
		return "--";
	case 87:
		return "++";
	case 88:
		return "~";
	case 89:
		return "!";
	case 90:
		return "=>";
	case 91:
		return "=";
	case 92:
		return "&&";
	case 93:
		return "||";
	case 94:
		return "/";
	case 95:
		return "==";
	case 96:
		return ">";
	case 97:
		return ">=";
	case 98:
		return "...";
	case 99:
		return "<";
	case 100:
		return "<=";
	case 101:
		return "%";
	case 102:
		return "*";
	case 103:
		return "!=";
	case 104:
		return "|";
	case 105:
		return "<<";
	case 106:
		return ">>";
	case 107:
		return "-";
	case 108:
		return ">>>";
	case 109:
		return "^";
	case 110:
		return "\\";
	case 111:
		return "+";
	case 112:
		return "&";
	case 113:
		return "?.";
	case 123:
		return "<!--default-->";
	}
};
var Typer = function() { };
Typer.__name__ = true;
Typer.fillScopes = function(allCode) {
	var scopes = [new Map()];
	var currentClass = [];
	var prevnode = null;
	var pushScope = function() {
		scopes.push(new Map());
	};
	var popScope = function() {
		scopes.pop();
	};
	var addScope = function(name,node) {
		scopes[scopes.length - 1].set(name,node);
	};
	var fail = function(msg,node1) {
		var data = Project.data.get(node1);
		if(data == null) {
			data = Project.data.get(prevnode);
		}
		if(data == null) {
			console.log(node1);
			console.log(prevnode);
			var _g = 0;
			var _g1 = Project.data.keys();
			while(_g < _g1.length) {
				var el = _g1[_g];
				++_g;
				console.log(Std.string(el) + ": " + Std.string(Project.data.get(el)));
			}
			return new CompilerError(Fail.TyperError,msg,0,0,"");
		}
		return new CompilerError(Fail.TyperError,msg,data.line,data.column,data.fileName);
	};
	var prevnode_s = null;
	var fill = null;
	fill = function(node2) {
		prevnode = node2;
		switch(node2[1]) {
		case 1:
			if(node2[2] == null) {
				throw new js__$Boot_HaxeError(new CompilerError(Fail.TyperError,"" + Std.string(node2)));
			} else {
				var name1 = node2[2];
				if(name1 == "s") {
					if(prevnode_s == null) {
						prevnode_s = node2;
					}
				}
				var subj = null;
				var _g11 = 0;
				var _g2 = scopes.length;
				while(_g11 < _g2) {
					var i = _g11++;
					subj = scopes[scopes.length - i - 1].get(name1);
					if(subj != null) {
						break;
					}
				}
				if(subj == null) {
					throw new js__$Boot_HaxeError(fail("Cannot find name `" + name1 + "` for " + Std.string(node2),node2));
				}
				if(Project.mapNames.get(node2) != null && Project.mapNames.get(node2) != subj) {
					var fill1 = "mapNames overwitten from " + Std.string(Project.mapNames.get(node2)) + " to ";
					throw new js__$Boot_HaxeError(fail(fill1 + Std.string(subj) + " for node " + Std.string(node2),node2));
				}
				Project.mapNames.set(node2,subj);
				var fill2 = subj[1] == 20;
			}
			break;
		case 3:case 4:
			Project.mapNames.set(node2,currentClass[currentClass.length - 1]);
			break;
		case 0:case 2:case 5:case 6:case 7:case 16:case 38:
			break;
		case 8:
			var b = node2[4];
			var a = node2[3];
			fill(a);
			fill(b);
			if(node2[1] == 8) {
				switch(node2[3][1]) {
				case 1:
					if(node2[2] == 91) {
						var parent = Project.mapNames.get(a);
						if(parent == null) {
							throw new js__$Boot_HaxeError(fail("null for node " + Std.string(a),node2));
						}
						if(parent[1] == 20) {
							if(parent[5] == true) {
								var name2 = parent[2];
								throw new js__$Boot_HaxeError(fail("Cannot reassign a constant `" + name2 + "`",node2));
							}
						}
					}
					break;
				case 24:
					break;
				default:
					if(node2[2] == 91) {
						throw new js__$Boot_HaxeError(fail("Cannot assign value to `" + Std.string(a) + "`",node2));
					}
				}
			}
			break;
		case 9:
			if(node2[2].length != 0) {
				var el1 = node2[2];
				pushScope();
				var _g3 = 0;
				while(_g3 < el1.length) {
					var e = el1[_g3];
					++_g3;
					fill(e);
				}
				popScope();
			}
			break;
		case 10:
			var elnames = node2[4];
			var el2 = node2[3];
			var e1 = node2[2];
			fill(e1);
			var _g4 = 0;
			while(_g4 < el2.length) {
				var e2 = el2[_g4];
				++_g4;
				fill(e2);
			}
			break;
		case 11:
			if(node2[4] == null) {
				var econd = node2[2];
				var eif = node2[3];
				var _g5 = 0;
				while(_g5 < econd.length) {
					var e3 = econd[_g5];
					++_g5;
					fill(e3);
				}
				fill(eif);
			} else {
				var econd1 = node2[2];
				var eif1 = node2[3];
				var eelse = node2[4];
				var _g6 = 0;
				while(_g6 < econd1.length) {
					var e4 = econd1[_g6];
					++_g6;
					fill(e4);
				}
				fill(eif1);
				fill(eelse);
			}
			break;
		case 12:
			var e5 = node2[2];
			fill(e5);
			break;
		case 13:
			if(node2[2] != null) {
				var e6 = node2[2];
				fill(e6);
			}
			break;
		case 14:
			var e7 = node2[2];
			fill(e7);
			break;
		case 15:
			break;
		case 17:
			var e8 = node2[4];
			fill(e8);
			break;
		case 18:
			var e9 = node2[3];
			var econd2 = node2[2];
			fill(econd2);
			fill(e9);
			break;
		case 19:
			var rettype = node2[5];
			var vars = node2[4];
			var expr = node2[3];
			var name3 = node2[2];
			if(name3 != null) {
				addScope(name3,node2);
			}
			pushScope();
			var _g7 = 0;
			while(_g7 < vars.length) {
				var v = vars[_g7];
				++_g7;
				switch(v[1]) {
				case 1:
					var vname = v[2];
					addScope(vname,v);
					break;
				case 12:
					if(v[2] != null) {
						throw new js__$Boot_HaxeError(fail(Std.string(v) + "",node2));
					}
					break;
				case 20:
					var vname1 = v[2];
					addScope(vname1,v);
					break;
				default:
					throw new js__$Boot_HaxeError(fail(Std.string(v) + "",node2));
				}
			}
			if(expr != null) {
				fill(expr);
			}
			popScope();
			break;
		case 20:
			if(node2[2] == null) {
				throw new js__$Boot_HaxeError(new CompilerError(Fail.TyperError,"" + Std.string(node2)));
			} else if(node2[4] == null) {
				if(node2[5] == true) {
					var name4 = node2[2];
					throw new js__$Boot_HaxeError(fail("Constant should have a value `let " + name4 + " = value`",node2));
				} else {
					var name5 = node2[2];
					var $const = node2[5];
					addScope(name5,node2);
				}
			} else {
				var const1 = node2[5];
				var name6 = node2[2];
				var e10 = node2[4];
				if(e10[1] == 22) {
					throw new js__$Boot_HaxeError(fail("Variable should not have class as a value",node2));
				}
				fill(e10);
				addScope(name6,node2);
			}
			break;
		case 21:
			var e11 = node2[2];
			var _g8 = 0;
			while(_g8 < e11.length) {
				var e12 = e11[_g8];
				++_g8;
				fill(e12);
			}
			break;
		case 22:
			var f = node2[5];
			var i1 = node2[4];
			var ex = node2[3];
			var t = node2[2];
			var name7 = Typer.extractTypeName(t);
			addScope(name7,node2);
			currentClass.push(node2);
			pushScope();
			var _g9 = 0;
			while(_g9 < f.length) {
				var field = f[_g9];
				++_g9;
				var name8;
				switch(field[1]) {
				case 19:
					if(field[2] == null) {
						name8 = "new";
					} else {
						var name9 = field[2];
						name8 = name9;
					}
					break;
				case 20:
					var name10 = field[2];
					name8 = name10;
					break;
				case 39:
					switch(field[2][1]) {
					case 19:
						var name11 = field[2][2];
						name8 = name11;
						break;
					case 20:
						var name12 = field[2][2];
						name8 = name12;
						break;
					default:
						throw new js__$Boot_HaxeError(fail("Incorrect class field node: " + Std.string(field),node2));
					}
					break;
				default:
					throw new js__$Boot_HaxeError(fail("Incorrect class field node: " + Std.string(field),node2));
				}
				var map = scopes[scopes.length - 1];
				if(map.has(name8)) {
					throw new js__$Boot_HaxeError(fail("Class field " + name8 + " already exists",node2));
				}
				map.set(name8,field);
				Project.mapNames.set(field,node2);
			}
			var _g10 = 0;
			while(_g10 < f.length) {
				var field1 = f[_g10];
				++_g10;
				switch(field1[1]) {
				case 19:
					if(field1[3] != null) {
						var r = field1[5];
						var v1 = field1[4];
						var e13 = field1[3];
						fill(Node.TFunction(null,e13,v1,r));
					}
					break;
				case 20:
					if(field1[4] != null) {
						var e14 = field1[4];
						fill(e14);
					}
					break;
				case 39:
					switch(field1[2][1]) {
					case 19:
						if(field1[2][3] != null) {
							var r1 = field1[2][5];
							var v2 = field1[2][4];
							var e15 = field1[2][3];
							fill(Node.TFunction(null,e15,v2,r1));
						}
						break;
					case 20:
						if(field1[2][4] != null) {
							var e16 = field1[2][4];
							fill(e16);
						}
						break;
					default:
					}
					break;
				default:
				}
			}
			popScope();
			currentClass.pop();
			break;
		case 23:
			var ca = node2[5];
			var v3 = node2[4];
			var t1 = node2[3];
			var e17 = node2[2];
			fill(e17);
			var _g12 = 0;
			var _g13 = ca.length;
			while(_g12 < _g13) {
				var e18 = _g12++;
				pushScope();
				scopes[scopes.length - 1].set(DataHelper.varName(v3[e18]),v3[e18]);
				fill(ca[e18]);
				popScope();
			}
			break;
		case 24:
			var n = node2[3];
			var e19 = node2[2];
			fill(e19);
			break;
		case 25:
			var values = node2[5];
			var names = node2[4];
			var el3 = node2[3];
			var t2 = node2[2];
			var _g14 = 0;
			while(_g14 < el3.length) {
				var e20 = el3[_g14];
				++_g14;
				fill(e20);
			}
			break;
		case 26:
			var el4 = node2[2];
			var _g15 = 0;
			while(_g15 < el4.length) {
				var e21 = el4[_g15];
				++_g15;
				fill(e21);
			}
			break;
		case 27:
			var values1 = node2[3];
			var keys = node2[2];
			var _g16 = 0;
			var _g17 = keys.length;
			while(_g16 < _g17) {
				var i2 = _g16++;
				fill(keys[i2]);
				fill(values1[i2]);
			}
			break;
		case 28:
			var i3 = node2[3];
			var e22 = node2[2];
			fill(e22);
			fill(i3);
			break;
		case 29:
			var cases = node2[4];
			var conds = node2[3];
			var exprs = node2[2];
			var _g18 = 0;
			while(_g18 < exprs.length) {
				var e23 = exprs[_g18];
				++_g18;
				pushScope();
				fill(e23);
				popScope();
			}
			var _g19 = 0;
			while(_g19 < conds.length) {
				var e24 = conds[_g19];
				++_g19;
				var _g110 = 0;
				while(_g110 < e24.length) {
					var e25 = e24[_g110];
					++_g110;
					pushScope();
					fill(e25);
					popScope();
				}
			}
			var _g20 = 0;
			while(_g20 < cases.length) {
				var e26 = cases[_g20];
				++_g20;
				pushScope();
				fill(e26);
				popScope();
			}
			break;
		case 30:
			throw new js__$Boot_HaxeError(fail("Modules should be at a file' upper scope",node2));
			break;
		case 31:
			var el5 = node2[3];
			var names1 = node2[2];
			var _g21 = 0;
			while(_g21 < el5.length) {
				var e27 = el5[_g21];
				++_g21;
				fill(e27);
			}
			break;
		case 32:
			var f1 = node2[3];
			var t3 = node2[2];
			var name13 = Typer.extractTypeName(t3);
			addScope(name13,node2);
			break;
		case 33:
			var name14 = node2[4];
			var extract = node2[3];
			var tenum = node2[2];
			break;
		case 34:
			switch(node2[3][1]) {
			case 8:
				if(node2[3][2] == 91) {
					if(node2[3][3][1] == 44) {
						if(node2[3][4][1] == 44) {
							var name15 = node2[2];
							var t4 = node2[3][3][2];
							var value = node2[3][4][2];
							switch(t4[1]) {
							case 0:
								var name16 = t4[2];
								addScope(name16,node2);
								break;
							case 1:
								var name17 = t4[2];
								addScope(name17,node2);
								break;
							default:
							}
						} else {
							var name18 = node2[2];
							var t5 = node2[3];
							addScope(name18,node2);
							fill(t5);
						}
					} else {
						var name19 = node2[2];
						var t6 = node2[3];
						addScope(name19,node2);
						fill(t6);
					}
				} else {
					var name20 = node2[2];
					var t7 = node2[3];
					addScope(name20,node2);
					fill(t7);
				}
				break;
			case 20:
				if(node2[3][4] == null) {
					if(node2[3][5] == true) {
						var name21 = node2[2];
						var t8 = node2[3][3];
						var vname2 = node2[3][2];
						var v4 = node2[3];
						addScope(name21,node2);
					} else {
						var name22 = node2[2];
						var t9 = node2[3];
						addScope(name22,node2);
						fill(t9);
					}
				} else {
					var name23 = node2[2];
					var t10 = node2[3];
					addScope(name23,node2);
					fill(t10);
				}
				break;
			default:
				var name24 = node2[2];
				var t11 = node2[3];
				addScope(name24,node2);
				fill(t11);
			}
			break;
		case 35:
			var names2 = node2[2];
			break;
		case 36:
			var el21 = node2[3];
			var el6 = node2[2];
			break;
		case 37:
			var e28 = node2[2];
			fill(e28);
			break;
		case 39:
			var e29 = node2[2];
			fill(e29);
			break;
		case 40:
			var f2 = node2[2];
			fill(f2);
			break;
		case 41:
			var f3 = node2[2];
			fill(f3);
			break;
		case 42:
			if(node2[2] == null) {
				throw new js__$Boot_HaxeError(new CompilerError(Fail.TyperError,"" + Std.string(node2)));
			} else {
				var by = node2[4];
				var over = node2[3];
				var name25 = node2[2];
				fill(over);
				pushScope();
				addScope(name25,node2);
				fill(by);
				popScope();
			}
			break;
		case 43:
			var b1 = node2[3];
			var a1 = node2[2];
			fill(a1);
			fill(b1);
			break;
		case 44:
			var t12 = node2[2];
			break;
		}
	};
	var fill3 = fill;
	var fillFile = function(file) {
		fill3(file);
	};
	var fillModule = function(module) {
		if(module[1] == 30) {
			var el7 = module[3];
			var path = module[2];
			console.log("-------> fillModule " + Std.string(path));
			var _g22 = 0;
			while(_g22 < el7.length) {
				var e30 = el7[_g22];
				++_g22;
				fill3(e30);
			}
		} else {
			console.log("-------> fillModule " + Std.string(module));
		}
	};
	if(allCode[1] == 9) {
		var files = allCode[2];
		pushScope();
		var _g23 = 0;
		while(_g23 < files.length) {
			var file1 = files[_g23];
			++_g23;
			switch(file1[1]) {
			case 9:
				var el8 = file1[2];
				var _g111 = 0;
				while(_g111 < el8.length) {
					var e31 = el8[_g111];
					++_g111;
					if(e31[1] == 30) {
						fillModule(e31);
					}
				}
				break;
			case 30:
				fillModule(file1);
				break;
			default:
			}
		}
		popScope();
		var _g24 = 0;
		while(_g24 < files.length) {
			var file2 = files[_g24];
			++_g24;
			pushScope();
			switch(file2[1]) {
			case 9:
				var el9 = file2[2];
				var _g112 = 0;
				while(_g112 < el9.length) {
					var e32 = el9[_g112];
					++_g112;
					if(e32[1] != 30) {
						fill3(e32);
					}
				}
				break;
			case 30:
				break;
			default:
				fill3(file2);
			}
			popScope();
		}
	} else {
		throw new js__$Boot_HaxeError("Typer expects all files to be collected into a block");
	}
};
Typer.extractTypeName = function(t) {
	switch(t[1]) {
	case 0:
		var name = t[2];
		return name;
	case 1:
		var name1 = t[2];
		return name1;
	default:
		throw new js__$Boot_HaxeError("Type has no name: " + Std.string(t));
	}
};
var haxe_IMap = function() { };
haxe_IMap.__name__ = true;
var haxe_ds_IntMap = function() {
	this.h = { };
};
haxe_ds_IntMap.__name__ = true;
haxe_ds_IntMap.__interfaces__ = [haxe_IMap];
haxe_ds_IntMap.prototype = {
	keys: function() {
		var a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) {
			a.push(key | 0);
		}
		return HxOverrides.iter(a);
	}
	,__class__: haxe_ds_IntMap
};
var haxe_ds_StringMap = function() {
	this.h = { };
};
haxe_ds_StringMap.__name__ = true;
haxe_ds_StringMap.__interfaces__ = [haxe_IMap];
haxe_ds_StringMap.prototype = {
	setReserved: function(key,value) {
		if(this.rh == null) {
			this.rh = { };
		}
		this.rh["$" + key] = value;
	}
	,getReserved: function(key) {
		if(this.rh == null) {
			return null;
		} else {
			return this.rh["$" + key];
		}
	}
	,__class__: haxe_ds_StringMap
};
var js__$Boot_HaxeError = function(val) {
	Error.call(this);
	this.val = val;
	this.message = String(val);
	if(Error.captureStackTrace) {
		Error.captureStackTrace(this,js__$Boot_HaxeError);
	}
};
js__$Boot_HaxeError.__name__ = true;
js__$Boot_HaxeError.wrap = function(val) {
	if((val instanceof Error)) {
		return val;
	} else {
		return new js__$Boot_HaxeError(val);
	}
};
js__$Boot_HaxeError.__super__ = Error;
js__$Boot_HaxeError.prototype = $extend(Error.prototype,{
	__class__: js__$Boot_HaxeError
});
var js_Boot = function() { };
js_Boot.__name__ = true;
js_Boot.getClass = function(o) {
	if((o instanceof Array) && o.__enum__ == null) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o instanceof Array) {
			if(o.__enum__) {
				if(o.length == 2) {
					return o[0];
				}
				var str = o[0] + "(";
				s += "\t";
				var _g1 = 2;
				var _g = o.length;
				while(_g1 < _g) {
					var i = _g1++;
					if(i != 2) {
						str += "," + js_Boot.__string_rec(o[i],s);
					} else {
						str += js_Boot.__string_rec(o[i],s);
					}
				}
				return str + ")";
			}
			var l = o.length;
			var i1;
			var str1 = "[";
			s += "\t";
			var _g11 = 0;
			var _g2 = l;
			while(_g11 < _g2) {
				var i2 = _g11++;
				str1 += (i2 > 0 ? "," : "") + js_Boot.__string_rec(o[i2],s);
			}
			str1 += "]";
			return str1;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( e ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var k = null;
		var str2 = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		for( var k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str2.length != 2) {
			str2 += ", \n";
		}
		str2 += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str2 += "\n" + s + "}";
		return str2;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__interfLoop = function(cc,cl) {
	if(cc == null) {
		return false;
	}
	if(cc == cl) {
		return true;
	}
	var intf = cc.__interfaces__;
	if(intf != null) {
		var _g1 = 0;
		var _g = intf.length;
		while(_g1 < _g) {
			var i = _g1++;
			var i1 = intf[i];
			if(i1 == cl || js_Boot.__interfLoop(i1,cl)) {
				return true;
			}
		}
	}
	return js_Boot.__interfLoop(cc.__super__,cl);
};
js_Boot.__instanceof = function(o,cl) {
	if(cl == null) {
		return false;
	}
	switch(cl) {
	case Array:
		if((o instanceof Array)) {
			return o.__enum__ == null;
		} else {
			return false;
		}
		break;
	case Bool:
		return typeof(o) == "boolean";
	case Dynamic:
		return true;
	case Float:
		return typeof(o) == "number";
	case Int:
		if(typeof(o) == "number") {
			return (o|0) === o;
		} else {
			return false;
		}
		break;
	case String:
		return typeof(o) == "string";
	default:
		if(o != null) {
			if(typeof(cl) == "function") {
				if(o instanceof cl) {
					return true;
				}
				if(js_Boot.__interfLoop(js_Boot.getClass(o),cl)) {
					return true;
				}
			} else if(typeof(cl) == "object" && js_Boot.__isNativeObj(cl)) {
				if(o instanceof cl) {
					return true;
				}
			}
		} else {
			return false;
		}
		if(cl == Class ? o.__name__ != null : false) {
			return true;
		}
		if(cl == Enum ? o.__ename__ != null : false) {
			return true;
		}
		return o.__enum__ == cl;
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__isNativeObj = function(o) {
	return js_Boot.__nativeClassName(o) != null;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var $_, $fid = 0;
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $fid++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = function(){ return f.method.apply(f.scope, arguments); }; f.scope = o; f.method = m; o.hx__closures__[m.__id__] = f; } return f; }
String.prototype.__class__ = String;
String.__name__ = true;
Array.__name__ = true;
var Int = { __name__ : ["Int"]};
var Dynamic = { __name__ : ["Dynamic"]};
var Float = Number;
Float.__name__ = ["Float"];
var Bool = Boolean;
Bool.__ename__ = ["Bool"];
var Class = { __name__ : ["Class"]};
var Enum = { };
var __map_reserved = {};
Project.mapAttributes = new Map();
Project.mapNames = new Map();
Project.data = new Map();
GenJs.id = 0;
GenJs.tabs = "";
GenJs.reserved = ["with"];
GenJs.parentNames = new Map();
GenJs.scopes = [new Map()];
js_Boot.__toStr = ({ }).toString;
OnlineCompiler.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);

//# sourceMappingURL=hexa-online.js.map
